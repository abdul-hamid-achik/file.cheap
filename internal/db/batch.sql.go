// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: batch.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countBatchItemsByStatus = `-- name: CountBatchItemsByStatus :one
SELECT 
    COUNT(*) FILTER (WHERE status = 'pending') AS pending,
    COUNT(*) FILTER (WHERE status = 'processing') AS processing,
    COUNT(*) FILTER (WHERE status = 'completed') AS completed,
    COUNT(*) FILTER (WHERE status = 'failed') AS failed
FROM batch_items WHERE batch_id = $1
`

type CountBatchItemsByStatusRow struct {
	Pending    int64 `json:"pending"`
	Processing int64 `json:"processing"`
	Completed  int64 `json:"completed"`
	Failed     int64 `json:"failed"`
}

func (q *Queries) CountBatchItemsByStatus(ctx context.Context, batchID pgtype.UUID) (CountBatchItemsByStatusRow, error) {
	row := q.db.QueryRow(ctx, countBatchItemsByStatus, batchID)
	var i CountBatchItemsByStatusRow
	err := row.Scan(
		&i.Pending,
		&i.Processing,
		&i.Completed,
		&i.Failed,
	)
	return i, err
}

const createBatchItem = `-- name: CreateBatchItem :one
INSERT INTO batch_items (batch_id, file_id, job_ids)
VALUES ($1, $2, $3)
RETURNING id, batch_id, file_id, status, job_ids, error_message, created_at, completed_at
`

type CreateBatchItemParams struct {
	BatchID pgtype.UUID `json:"batch_id"`
	FileID  pgtype.UUID `json:"file_id"`
	JobIds  []string    `json:"job_ids"`
}

func (q *Queries) CreateBatchItem(ctx context.Context, arg CreateBatchItemParams) (BatchItem, error) {
	row := q.db.QueryRow(ctx, createBatchItem, arg.BatchID, arg.FileID, arg.JobIds)
	var i BatchItem
	err := row.Scan(
		&i.ID,
		&i.BatchID,
		&i.FileID,
		&i.Status,
		&i.JobIds,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const createBatchOperation = `-- name: CreateBatchOperation :one
INSERT INTO batch_operations (user_id, total_files, presets, webp, quality, watermark)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, status, total_files, completed_files, failed_files, presets, webp, quality, watermark, error_message, created_at, started_at, completed_at
`

type CreateBatchOperationParams struct {
	UserID     pgtype.UUID `json:"user_id"`
	TotalFiles int32       `json:"total_files"`
	Presets    []string    `json:"presets"`
	Webp       bool        `json:"webp"`
	Quality    int32       `json:"quality"`
	Watermark  *string     `json:"watermark"`
}

func (q *Queries) CreateBatchOperation(ctx context.Context, arg CreateBatchOperationParams) (BatchOperation, error) {
	row := q.db.QueryRow(ctx, createBatchOperation,
		arg.UserID,
		arg.TotalFiles,
		arg.Presets,
		arg.Webp,
		arg.Quality,
		arg.Watermark,
	)
	var i BatchOperation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.TotalFiles,
		&i.CompletedFiles,
		&i.FailedFiles,
		&i.Presets,
		&i.Webp,
		&i.Quality,
		&i.Watermark,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getBatchItem = `-- name: GetBatchItem :one
SELECT id, batch_id, file_id, status, job_ids, error_message, created_at, completed_at FROM batch_items WHERE id = $1
`

func (q *Queries) GetBatchItem(ctx context.Context, id pgtype.UUID) (BatchItem, error) {
	row := q.db.QueryRow(ctx, getBatchItem, id)
	var i BatchItem
	err := row.Scan(
		&i.ID,
		&i.BatchID,
		&i.FileID,
		&i.Status,
		&i.JobIds,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getBatchOperation = `-- name: GetBatchOperation :one
SELECT id, user_id, status, total_files, completed_files, failed_files, presets, webp, quality, watermark, error_message, created_at, started_at, completed_at FROM batch_operations WHERE id = $1
`

func (q *Queries) GetBatchOperation(ctx context.Context, id pgtype.UUID) (BatchOperation, error) {
	row := q.db.QueryRow(ctx, getBatchOperation, id)
	var i BatchOperation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.TotalFiles,
		&i.CompletedFiles,
		&i.FailedFiles,
		&i.Presets,
		&i.Webp,
		&i.Quality,
		&i.Watermark,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getBatchOperationByUser = `-- name: GetBatchOperationByUser :one
SELECT id, user_id, status, total_files, completed_files, failed_files, presets, webp, quality, watermark, error_message, created_at, started_at, completed_at FROM batch_operations WHERE id = $1 AND user_id = $2
`

type GetBatchOperationByUserParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetBatchOperationByUser(ctx context.Context, arg GetBatchOperationByUserParams) (BatchOperation, error) {
	row := q.db.QueryRow(ctx, getBatchOperationByUser, arg.ID, arg.UserID)
	var i BatchOperation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.TotalFiles,
		&i.CompletedFiles,
		&i.FailedFiles,
		&i.Presets,
		&i.Webp,
		&i.Quality,
		&i.Watermark,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const incrementBatchCompletedFiles = `-- name: IncrementBatchCompletedFiles :exec
UPDATE batch_operations 
SET completed_files = completed_files + 1
WHERE id = $1
`

func (q *Queries) IncrementBatchCompletedFiles(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, incrementBatchCompletedFiles, id)
	return err
}

const incrementBatchFailedFiles = `-- name: IncrementBatchFailedFiles :exec
UPDATE batch_operations 
SET failed_files = failed_files + 1
WHERE id = $1
`

func (q *Queries) IncrementBatchFailedFiles(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, incrementBatchFailedFiles, id)
	return err
}

const listBatchItems = `-- name: ListBatchItems :many
SELECT id, batch_id, file_id, status, job_ids, error_message, created_at, completed_at FROM batch_items WHERE batch_id = $1 ORDER BY created_at
`

func (q *Queries) ListBatchItems(ctx context.Context, batchID pgtype.UUID) ([]BatchItem, error) {
	rows, err := q.db.Query(ctx, listBatchItems, batchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BatchItem
	for rows.Next() {
		var i BatchItem
		if err := rows.Scan(
			&i.ID,
			&i.BatchID,
			&i.FileID,
			&i.Status,
			&i.JobIds,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBatchOperationsByUser = `-- name: ListBatchOperationsByUser :many
SELECT id, user_id, status, total_files, completed_files, failed_files, presets, webp, quality, watermark, error_message, created_at, started_at, completed_at FROM batch_operations WHERE user_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListBatchOperationsByUserParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListBatchOperationsByUser(ctx context.Context, arg ListBatchOperationsByUserParams) ([]BatchOperation, error) {
	rows, err := q.db.Query(ctx, listBatchOperationsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BatchOperation
	for rows.Next() {
		var i BatchOperation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.TotalFiles,
			&i.CompletedFiles,
			&i.FailedFiles,
			&i.Presets,
			&i.Webp,
			&i.Quality,
			&i.Watermark,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBatchItemStatus = `-- name: UpdateBatchItemStatus :exec
UPDATE batch_items 
SET status = $2, error_message = $3, completed_at = CASE WHEN $2 IN ('completed', 'failed') THEN NOW() ELSE completed_at END
WHERE id = $1
`

type UpdateBatchItemStatusParams struct {
	ID           pgtype.UUID `json:"id"`
	Status       BatchStatus `json:"status"`
	ErrorMessage *string     `json:"error_message"`
}

func (q *Queries) UpdateBatchItemStatus(ctx context.Context, arg UpdateBatchItemStatusParams) error {
	_, err := q.db.Exec(ctx, updateBatchItemStatus, arg.ID, arg.Status, arg.ErrorMessage)
	return err
}

const updateBatchOperationCompleted = `-- name: UpdateBatchOperationCompleted :exec
UPDATE batch_operations 
SET status = $2, completed_at = NOW(), error_message = $3
WHERE id = $1
`

type UpdateBatchOperationCompletedParams struct {
	ID           pgtype.UUID `json:"id"`
	Status       BatchStatus `json:"status"`
	ErrorMessage *string     `json:"error_message"`
}

func (q *Queries) UpdateBatchOperationCompleted(ctx context.Context, arg UpdateBatchOperationCompletedParams) error {
	_, err := q.db.Exec(ctx, updateBatchOperationCompleted, arg.ID, arg.Status, arg.ErrorMessage)
	return err
}

const updateBatchOperationStatus = `-- name: UpdateBatchOperationStatus :exec
UPDATE batch_operations 
SET status = $2, started_at = COALESCE(started_at, NOW()), updated_at = NOW()
WHERE id = $1
`

type UpdateBatchOperationStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status BatchStatus `json:"status"`
}

func (q *Queries) UpdateBatchOperationStatus(ctx context.Context, arg UpdateBatchOperationStatusParams) error {
	_, err := q.db.Exec(ctx, updateBatchOperationStatus, arg.ID, arg.Status)
	return err
}
