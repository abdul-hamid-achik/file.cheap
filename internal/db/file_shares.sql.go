// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: file_shares.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFileShare = `-- name: CreateFileShare :one
INSERT INTO file_shares (file_id, token, expires_at, allowed_transforms, password_hash, max_downloads)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, file_id, token, expires_at, allowed_transforms, access_count, password_hash, max_downloads, download_count, created_at
`

type CreateFileShareParams struct {
	FileID            pgtype.UUID        `json:"file_id"`
	Token             string             `json:"token"`
	ExpiresAt         pgtype.Timestamptz `json:"expires_at"`
	AllowedTransforms []string           `json:"allowed_transforms"`
	PasswordHash      *string            `json:"password_hash"`
	MaxDownloads      *int32             `json:"max_downloads"`
}

func (q *Queries) CreateFileShare(ctx context.Context, arg CreateFileShareParams) (FileShare, error) {
	row := q.db.QueryRow(ctx, createFileShare,
		arg.FileID,
		arg.Token,
		arg.ExpiresAt,
		arg.AllowedTransforms,
		arg.PasswordHash,
		arg.MaxDownloads,
	)
	var i FileShare
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.Token,
		&i.ExpiresAt,
		&i.AllowedTransforms,
		&i.AccessCount,
		&i.PasswordHash,
		&i.MaxDownloads,
		&i.DownloadCount,
		&i.CreatedAt,
	)
	return i, err
}

const createTransformCache = `-- name: CreateTransformCache :one
INSERT INTO transform_cache (file_id, cache_key, transform_params, storage_key, content_type, size_bytes, width, height)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (file_id, cache_key) DO UPDATE SET
    request_count = transform_cache.request_count + 1,
    last_accessed_at = NOW()
RETURNING id, file_id, cache_key, transform_params, storage_key, content_type, size_bytes, width, height, request_count, created_at, last_accessed_at
`

type CreateTransformCacheParams struct {
	FileID          pgtype.UUID `json:"file_id"`
	CacheKey        string      `json:"cache_key"`
	TransformParams string      `json:"transform_params"`
	StorageKey      string      `json:"storage_key"`
	ContentType     string      `json:"content_type"`
	SizeBytes       int64       `json:"size_bytes"`
	Width           *int32      `json:"width"`
	Height          *int32      `json:"height"`
}

func (q *Queries) CreateTransformCache(ctx context.Context, arg CreateTransformCacheParams) (TransformCache, error) {
	row := q.db.QueryRow(ctx, createTransformCache,
		arg.FileID,
		arg.CacheKey,
		arg.TransformParams,
		arg.StorageKey,
		arg.ContentType,
		arg.SizeBytes,
		arg.Width,
		arg.Height,
	)
	var i TransformCache
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.CacheKey,
		&i.TransformParams,
		&i.StorageKey,
		&i.ContentType,
		&i.SizeBytes,
		&i.Width,
		&i.Height,
		&i.RequestCount,
		&i.CreatedAt,
		&i.LastAccessedAt,
	)
	return i, err
}

const deleteExpiredShares = `-- name: DeleteExpiredShares :exec
DELETE FROM file_shares
WHERE expires_at IS NOT NULL AND expires_at < NOW()
`

func (q *Queries) DeleteExpiredShares(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredShares)
	return err
}

const deleteFileShare = `-- name: DeleteFileShare :exec
DELETE FROM file_shares
WHERE file_shares.id = $1 AND file_id IN (SELECT files.id FROM files WHERE files.user_id = $2)
`

type DeleteFileShareParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteFileShare(ctx context.Context, arg DeleteFileShareParams) error {
	_, err := q.db.Exec(ctx, deleteFileShare, arg.ID, arg.UserID)
	return err
}

const deleteOldTransformCache = `-- name: DeleteOldTransformCache :exec
DELETE FROM transform_cache
WHERE last_accessed_at < NOW() - INTERVAL '30 days'
  AND request_count < 10
`

func (q *Queries) DeleteOldTransformCache(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteOldTransformCache)
	return err
}

const getFileShareByToken = `-- name: GetFileShareByToken :one
SELECT s.id, s.file_id, s.token, s.expires_at, s.allowed_transforms, s.access_count, s.password_hash, s.max_downloads, s.download_count, s.created_at, f.storage_key, f.content_type, f.user_id, f.filename
FROM file_shares s
JOIN files f ON f.id = s.file_id
WHERE s.token = $1
  AND (s.expires_at IS NULL OR s.expires_at > NOW())
  AND f.deleted_at IS NULL
`

type GetFileShareByTokenRow struct {
	ID                pgtype.UUID        `json:"id"`
	FileID            pgtype.UUID        `json:"file_id"`
	Token             string             `json:"token"`
	ExpiresAt         pgtype.Timestamptz `json:"expires_at"`
	AllowedTransforms []string           `json:"allowed_transforms"`
	AccessCount       int32              `json:"access_count"`
	PasswordHash      *string            `json:"password_hash"`
	MaxDownloads      *int32             `json:"max_downloads"`
	DownloadCount     int32              `json:"download_count"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	StorageKey        string             `json:"storage_key"`
	ContentType       string             `json:"content_type"`
	UserID            pgtype.UUID        `json:"user_id"`
	Filename          string             `json:"filename"`
}

func (q *Queries) GetFileShareByToken(ctx context.Context, token string) (GetFileShareByTokenRow, error) {
	row := q.db.QueryRow(ctx, getFileShareByToken, token)
	var i GetFileShareByTokenRow
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.Token,
		&i.ExpiresAt,
		&i.AllowedTransforms,
		&i.AccessCount,
		&i.PasswordHash,
		&i.MaxDownloads,
		&i.DownloadCount,
		&i.CreatedAt,
		&i.StorageKey,
		&i.ContentType,
		&i.UserID,
		&i.Filename,
	)
	return i, err
}

const getTransformCache = `-- name: GetTransformCache :one
SELECT id, file_id, cache_key, transform_params, storage_key, content_type, size_bytes, width, height, request_count, created_at, last_accessed_at FROM transform_cache
WHERE file_id = $1 AND cache_key = $2
`

type GetTransformCacheParams struct {
	FileID   pgtype.UUID `json:"file_id"`
	CacheKey string      `json:"cache_key"`
}

func (q *Queries) GetTransformCache(ctx context.Context, arg GetTransformCacheParams) (TransformCache, error) {
	row := q.db.QueryRow(ctx, getTransformCache, arg.FileID, arg.CacheKey)
	var i TransformCache
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.CacheKey,
		&i.TransformParams,
		&i.StorageKey,
		&i.ContentType,
		&i.SizeBytes,
		&i.Width,
		&i.Height,
		&i.RequestCount,
		&i.CreatedAt,
		&i.LastAccessedAt,
	)
	return i, err
}

const getTransformRequestCount = `-- name: GetTransformRequestCount :one
SELECT COALESCE(
    (SELECT request_count FROM transform_cache WHERE file_id = $1 AND cache_key = $2),
    0
)::int AS count
`

type GetTransformRequestCountParams struct {
	FileID   pgtype.UUID `json:"file_id"`
	CacheKey string      `json:"cache_key"`
}

func (q *Queries) GetTransformRequestCount(ctx context.Context, arg GetTransformRequestCountParams) (int32, error) {
	row := q.db.QueryRow(ctx, getTransformRequestCount, arg.FileID, arg.CacheKey)
	var count int32
	err := row.Scan(&count)
	return count, err
}

const incrementShareAccessCount = `-- name: IncrementShareAccessCount :exec
UPDATE file_shares
SET access_count = access_count + 1
WHERE id = $1
`

func (q *Queries) IncrementShareAccessCount(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, incrementShareAccessCount, id)
	return err
}

const incrementShareDownloadCount = `-- name: IncrementShareDownloadCount :exec
UPDATE file_shares
SET download_count = download_count + 1
WHERE id = $1
`

func (q *Queries) IncrementShareDownloadCount(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, incrementShareDownloadCount, id)
	return err
}

const incrementTransformCacheCount = `-- name: IncrementTransformCacheCount :exec
UPDATE transform_cache
SET request_count = request_count + 1, last_accessed_at = NOW()
WHERE file_id = $1 AND cache_key = $2
`

type IncrementTransformCacheCountParams struct {
	FileID   pgtype.UUID `json:"file_id"`
	CacheKey string      `json:"cache_key"`
}

func (q *Queries) IncrementTransformCacheCount(ctx context.Context, arg IncrementTransformCacheCountParams) error {
	_, err := q.db.Exec(ctx, incrementTransformCacheCount, arg.FileID, arg.CacheKey)
	return err
}

const isShareDownloadLimitReached = `-- name: IsShareDownloadLimitReached :one
SELECT CASE
    WHEN max_downloads IS NULL THEN false
    WHEN download_count >= max_downloads THEN true
    ELSE false
END AS limit_reached
FROM file_shares
WHERE id = $1
`

func (q *Queries) IsShareDownloadLimitReached(ctx context.Context, id pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, isShareDownloadLimitReached, id)
	var limit_reached bool
	err := row.Scan(&limit_reached)
	return limit_reached, err
}

const listFileSharesByFile = `-- name: ListFileSharesByFile :many
SELECT id, file_id, token, expires_at, allowed_transforms, access_count, password_hash, max_downloads, download_count, created_at FROM file_shares
WHERE file_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListFileSharesByFile(ctx context.Context, fileID pgtype.UUID) ([]FileShare, error) {
	rows, err := q.db.Query(ctx, listFileSharesByFile, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FileShare
	for rows.Next() {
		var i FileShare
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.Token,
			&i.ExpiresAt,
			&i.AllowedTransforms,
			&i.AccessCount,
			&i.PasswordHash,
			&i.MaxDownloads,
			&i.DownloadCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
