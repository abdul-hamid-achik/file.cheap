// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: usage.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const ensureMonthlyUsageRecord = `-- name: EnsureMonthlyUsageRecord :exec
INSERT INTO monthly_usage (user_id, year_month, transformations_count, bytes_processed, files_uploaded, video_seconds_processed)
VALUES ($1, TO_CHAR(NOW(), 'YYYY-MM'), 0, 0, 0, 0)
ON CONFLICT (user_id, year_month) DO NOTHING
`

func (q *Queries) EnsureMonthlyUsageRecord(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, ensureMonthlyUsageRecord, userID)
	return err
}

const getCurrentMonthUsage = `-- name: GetCurrentMonthUsage :one
SELECT id, user_id, year_month, transformations_count, bytes_processed, files_uploaded, video_seconds_processed, created_at, updated_at FROM monthly_usage 
WHERE user_id = $1 AND year_month = TO_CHAR(NOW(), 'YYYY-MM')
`

func (q *Queries) GetCurrentMonthUsage(ctx context.Context, userID pgtype.UUID) (MonthlyUsage, error) {
	row := q.db.QueryRow(ctx, getCurrentMonthUsage, userID)
	var i MonthlyUsage
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.YearMonth,
		&i.TransformationsCount,
		&i.BytesProcessed,
		&i.FilesUploaded,
		&i.VideoSecondsProcessed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserTransformationUsage = `-- name: GetUserTransformationUsage :one
SELECT transformations_count, transformations_limit, transformations_reset_at
FROM users WHERE id = $1 AND deleted_at IS NULL
`

type GetUserTransformationUsageRow struct {
	TransformationsCount   int32              `json:"transformations_count"`
	TransformationsLimit   int32              `json:"transformations_limit"`
	TransformationsResetAt pgtype.Timestamptz `json:"transformations_reset_at"`
}

func (q *Queries) GetUserTransformationUsage(ctx context.Context, id pgtype.UUID) (GetUserTransformationUsageRow, error) {
	row := q.db.QueryRow(ctx, getUserTransformationUsage, id)
	var i GetUserTransformationUsageRow
	err := row.Scan(&i.TransformationsCount, &i.TransformationsLimit, &i.TransformationsResetAt)
	return i, err
}

const getVideoSecondsProcessed = `-- name: GetVideoSecondsProcessed :one
SELECT COALESCE(video_seconds_processed, 0)::integer as video_seconds
FROM monthly_usage
WHERE user_id = $1 AND year_month = TO_CHAR(NOW(), 'YYYY-MM')
`

func (q *Queries) GetVideoSecondsProcessed(ctx context.Context, userID pgtype.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getVideoSecondsProcessed, userID)
	var video_seconds int32
	err := row.Scan(&video_seconds)
	return video_seconds, err
}

const incrementTransformationCount = `-- name: IncrementTransformationCount :exec
UPDATE users 
SET transformations_count = transformations_count + 1, updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) IncrementTransformationCount(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, incrementTransformationCount, id)
	return err
}

const incrementVideoSecondsProcessed = `-- name: IncrementVideoSecondsProcessed :exec
UPDATE monthly_usage
SET video_seconds_processed = video_seconds_processed + $2, updated_at = NOW()
WHERE user_id = $1 AND year_month = TO_CHAR(NOW(), 'YYYY-MM')
`

type IncrementVideoSecondsProcessedParams struct {
	UserID                pgtype.UUID `json:"user_id"`
	VideoSecondsProcessed int32       `json:"video_seconds_processed"`
}

func (q *Queries) IncrementVideoSecondsProcessed(ctx context.Context, arg IncrementVideoSecondsProcessedParams) error {
	_, err := q.db.Exec(ctx, incrementVideoSecondsProcessed, arg.UserID, arg.VideoSecondsProcessed)
	return err
}

const listMonthlyUsageHistory = `-- name: ListMonthlyUsageHistory :many
SELECT id, user_id, year_month, transformations_count, bytes_processed, files_uploaded, video_seconds_processed, created_at, updated_at FROM monthly_usage
WHERE user_id = $1
ORDER BY year_month DESC
LIMIT $2
`

type ListMonthlyUsageHistoryParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
}

func (q *Queries) ListMonthlyUsageHistory(ctx context.Context, arg ListMonthlyUsageHistoryParams) ([]MonthlyUsage, error) {
	rows, err := q.db.Query(ctx, listMonthlyUsageHistory, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MonthlyUsage
	for rows.Next() {
		var i MonthlyUsage
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.YearMonth,
			&i.TransformationsCount,
			&i.BytesProcessed,
			&i.FilesUploaded,
			&i.VideoSecondsProcessed,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetExpiredTransformations = `-- name: ResetExpiredTransformations :exec
UPDATE users 
SET transformations_count = 0, 
    transformations_reset_at = DATE_TRUNC('month', NOW()) + INTERVAL '1 month',
    updated_at = NOW()
WHERE transformations_reset_at <= NOW() AND deleted_at IS NULL
`

func (q *Queries) ResetExpiredTransformations(ctx context.Context) error {
	_, err := q.db.Exec(ctx, resetExpiredTransformations)
	return err
}

const updateUserTransformationLimit = `-- name: UpdateUserTransformationLimit :exec
UPDATE users
SET transformations_limit = $2, updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateUserTransformationLimitParams struct {
	ID                   pgtype.UUID `json:"id"`
	TransformationsLimit int32       `json:"transformations_limit"`
}

func (q *Queries) UpdateUserTransformationLimit(ctx context.Context, arg UpdateUserTransformationLimitParams) error {
	_, err := q.db.Exec(ctx, updateUserTransformationLimit, arg.ID, arg.TransformationsLimit)
	return err
}

const upsertMonthlyUsage = `-- name: UpsertMonthlyUsage :one
INSERT INTO monthly_usage (user_id, year_month, transformations_count, bytes_processed, files_uploaded)
VALUES ($1, TO_CHAR(NOW(), 'YYYY-MM'), $2, $3, $4)
ON CONFLICT (user_id, year_month) DO UPDATE SET
    transformations_count = monthly_usage.transformations_count + EXCLUDED.transformations_count,
    bytes_processed = monthly_usage.bytes_processed + EXCLUDED.bytes_processed,
    files_uploaded = monthly_usage.files_uploaded + EXCLUDED.files_uploaded,
    updated_at = NOW()
RETURNING id, user_id, year_month, transformations_count, bytes_processed, files_uploaded, video_seconds_processed, created_at, updated_at
`

type UpsertMonthlyUsageParams struct {
	UserID               pgtype.UUID `json:"user_id"`
	TransformationsCount int32       `json:"transformations_count"`
	BytesProcessed       int64       `json:"bytes_processed"`
	FilesUploaded        int32       `json:"files_uploaded"`
}

func (q *Queries) UpsertMonthlyUsage(ctx context.Context, arg UpsertMonthlyUsageParams) (MonthlyUsage, error) {
	row := q.db.QueryRow(ctx, upsertMonthlyUsage,
		arg.UserID,
		arg.TransformationsCount,
		arg.BytesProcessed,
		arg.FilesUploaded,
	)
	var i MonthlyUsage
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.YearMonth,
		&i.TransformationsCount,
		&i.BytesProcessed,
		&i.FilesUploaded,
		&i.VideoSecondsProcessed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
