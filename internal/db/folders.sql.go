// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: folders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countFolderContents = `-- name: CountFolderContents :one
SELECT
    (SELECT COUNT(*) FROM folders WHERE parent_id = $1) AS folder_count,
    (SELECT COUNT(*) FROM files WHERE folder_id = $1 AND deleted_at IS NULL) AS file_count
`

type CountFolderContentsRow struct {
	FolderCount int64 `json:"folder_count"`
	FileCount   int64 `json:"file_count"`
}

func (q *Queries) CountFolderContents(ctx context.Context, parentID pgtype.UUID) (CountFolderContentsRow, error) {
	row := q.db.QueryRow(ctx, countFolderContents, parentID)
	var i CountFolderContentsRow
	err := row.Scan(&i.FolderCount, &i.FileCount)
	return i, err
}

const createFolder = `-- name: CreateFolder :one
INSERT INTO folders (user_id, parent_id, name, path)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, parent_id, name, path, created_at, updated_at
`

type CreateFolderParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	ParentID pgtype.UUID `json:"parent_id"`
	Name     string      `json:"name"`
	Path     string      `json:"path"`
}

func (q *Queries) CreateFolder(ctx context.Context, arg CreateFolderParams) (Folder, error) {
	row := q.db.QueryRow(ctx, createFolder,
		arg.UserID,
		arg.ParentID,
		arg.Name,
		arg.Path,
	)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ParentID,
		&i.Name,
		&i.Path,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFolder = `-- name: DeleteFolder :exec
DELETE FROM folders
WHERE id = $1 AND user_id = $2
`

type DeleteFolderParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteFolder(ctx context.Context, arg DeleteFolderParams) error {
	_, err := q.db.Exec(ctx, deleteFolder, arg.ID, arg.UserID)
	return err
}

const deleteFolderRecursive = `-- name: DeleteFolderRecursive :exec
WITH RECURSIVE folder_tree AS (
    SELECT folders.id FROM folders WHERE folders.id = $1 AND folders.user_id = $2
    UNION ALL
    SELECT f.id FROM folders f
    INNER JOIN folder_tree ft ON f.parent_id = ft.id
)
DELETE FROM folders WHERE folders.id IN (SELECT folder_tree.id FROM folder_tree)
`

type DeleteFolderRecursiveParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteFolderRecursive(ctx context.Context, arg DeleteFolderRecursiveParams) error {
	_, err := q.db.Exec(ctx, deleteFolderRecursive, arg.ID, arg.UserID)
	return err
}

const getFolder = `-- name: GetFolder :one
SELECT id, user_id, parent_id, name, path, created_at, updated_at FROM folders
WHERE id = $1 AND user_id = $2
`

type GetFolderParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetFolder(ctx context.Context, arg GetFolderParams) (Folder, error) {
	row := q.db.QueryRow(ctx, getFolder, arg.ID, arg.UserID)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ParentID,
		&i.Name,
		&i.Path,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFolderByPath = `-- name: GetFolderByPath :one
SELECT id, user_id, parent_id, name, path, created_at, updated_at FROM folders
WHERE user_id = $1 AND path = $2
`

type GetFolderByPathParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Path   string      `json:"path"`
}

func (q *Queries) GetFolderByPath(ctx context.Context, arg GetFolderByPathParams) (Folder, error) {
	row := q.db.QueryRow(ctx, getFolderByPath, arg.UserID, arg.Path)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ParentID,
		&i.Name,
		&i.Path,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFolderPath = `-- name: GetFolderPath :many
WITH RECURSIVE folder_path AS (
    SELECT folders.id, folders.parent_id, folders.name, folders.path, 1 as depth
    FROM folders
    WHERE folders.id = $1 AND folders.user_id = $2
    UNION ALL
    SELECT f.id, f.parent_id, f.name, f.path, fp.depth + 1
    FROM folders f
    INNER JOIN folder_path fp ON f.id = fp.parent_id
)
SELECT folder_path.id, folder_path.name, folder_path.path FROM folder_path
ORDER BY depth DESC
`

type GetFolderPathParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

type GetFolderPathRow struct {
	ID   pgtype.UUID `json:"id"`
	Name string      `json:"name"`
	Path string      `json:"path"`
}

func (q *Queries) GetFolderPath(ctx context.Context, arg GetFolderPathParams) ([]GetFolderPathRow, error) {
	rows, err := q.db.Query(ctx, getFolderPath, arg.ID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFolderPathRow
	for rows.Next() {
		var i GetFolderPathRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Path); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesInFolder = `-- name: ListFilesInFolder :many
SELECT id, user_id, folder_id, filename, content_type, size_bytes, storage_key, status, created_at, updated_at, deleted_at FROM files
WHERE user_id = $1 AND folder_id = $2 AND deleted_at IS NULL
ORDER BY filename ASC
`

type ListFilesInFolderParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	FolderID pgtype.UUID `json:"folder_id"`
}

func (q *Queries) ListFilesInFolder(ctx context.Context, arg ListFilesInFolderParams) ([]File, error) {
	rows, err := q.db.Query(ctx, listFilesInFolder, arg.UserID, arg.FolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FolderID,
			&i.Filename,
			&i.ContentType,
			&i.SizeBytes,
			&i.StorageKey,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesInRoot = `-- name: ListFilesInRoot :many
SELECT id, user_id, folder_id, filename, content_type, size_bytes, storage_key, status, created_at, updated_at, deleted_at FROM files
WHERE user_id = $1 AND folder_id IS NULL AND deleted_at IS NULL
ORDER BY filename ASC
`

func (q *Queries) ListFilesInRoot(ctx context.Context, userID pgtype.UUID) ([]File, error) {
	rows, err := q.db.Query(ctx, listFilesInRoot, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FolderID,
			&i.Filename,
			&i.ContentType,
			&i.SizeBytes,
			&i.StorageKey,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFolderChildren = `-- name: ListFolderChildren :many
SELECT id, user_id, parent_id, name, path, created_at, updated_at FROM folders
WHERE user_id = $1 AND parent_id = $2
ORDER BY name ASC
`

type ListFolderChildrenParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	ParentID pgtype.UUID `json:"parent_id"`
}

func (q *Queries) ListFolderChildren(ctx context.Context, arg ListFolderChildrenParams) ([]Folder, error) {
	rows, err := q.db.Query(ctx, listFolderChildren, arg.UserID, arg.ParentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Folder
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ParentID,
			&i.Name,
			&i.Path,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRootFolders = `-- name: ListRootFolders :many
SELECT id, user_id, parent_id, name, path, created_at, updated_at FROM folders
WHERE user_id = $1 AND parent_id IS NULL
ORDER BY name ASC
`

func (q *Queries) ListRootFolders(ctx context.Context, userID pgtype.UUID) ([]Folder, error) {
	rows, err := q.db.Query(ctx, listRootFolders, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Folder
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ParentID,
			&i.Name,
			&i.Path,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const moveFileToFolder = `-- name: MoveFileToFolder :exec
UPDATE files
SET folder_id = $3, updated_at = NOW()
WHERE id = $1 AND user_id = $2 AND deleted_at IS NULL
`

type MoveFileToFolderParams struct {
	ID       pgtype.UUID `json:"id"`
	UserID   pgtype.UUID `json:"user_id"`
	FolderID pgtype.UUID `json:"folder_id"`
}

func (q *Queries) MoveFileToFolder(ctx context.Context, arg MoveFileToFolderParams) error {
	_, err := q.db.Exec(ctx, moveFileToFolder, arg.ID, arg.UserID, arg.FolderID)
	return err
}

const moveFileToRoot = `-- name: MoveFileToRoot :exec
UPDATE files
SET folder_id = NULL, updated_at = NOW()
WHERE id = $1 AND user_id = $2 AND deleted_at IS NULL
`

type MoveFileToRootParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) MoveFileToRoot(ctx context.Context, arg MoveFileToRootParams) error {
	_, err := q.db.Exec(ctx, moveFileToRoot, arg.ID, arg.UserID)
	return err
}

const updateFolder = `-- name: UpdateFolder :one
UPDATE folders
SET name = $3, path = $4, parent_id = $5, updated_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, parent_id, name, path, created_at, updated_at
`

type UpdateFolderParams struct {
	ID       pgtype.UUID `json:"id"`
	UserID   pgtype.UUID `json:"user_id"`
	Name     string      `json:"name"`
	Path     string      `json:"path"`
	ParentID pgtype.UUID `json:"parent_id"`
}

func (q *Queries) UpdateFolder(ctx context.Context, arg UpdateFolderParams) (Folder, error) {
	row := q.db.QueryRow(ctx, updateFolder,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.Path,
		arg.ParentID,
	)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ParentID,
		&i.Name,
		&i.Path,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
