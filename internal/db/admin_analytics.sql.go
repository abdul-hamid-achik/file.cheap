// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: admin_analytics.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countJobsAdmin = `-- name: CountJobsAdmin :one
SELECT COUNT(*)::bigint as total
FROM processing_jobs
WHERE ($1::text IS NULL OR status::text = $1)
`

func (q *Queries) CountJobsAdmin(ctx context.Context, status *string) (int64, error) {
	row := q.db.QueryRow(ctx, countJobsAdmin, status)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getAdminMetrics = `-- name: GetAdminMetrics :one
SELECT
    COALESCE(
        SUM(CASE subscription_tier 
            WHEN 'pro' THEN 19.00 
            WHEN 'enterprise' THEN 99.00 
            ELSE 0 
        END), 0
    )::float8 as mrr,
    COUNT(*)::bigint as total_users,
    COUNT(*) FILTER (
        WHERE created_at >= NOW() - INTERVAL '7 days'
    )::bigint as new_users_this_week
FROM users
WHERE deleted_at IS NULL 
    AND (subscription_status IN ('active', 'trialing') OR subscription_tier = 'free')
`

type GetAdminMetricsRow struct {
	Mrr              float64 `json:"mrr"`
	TotalUsers       int64   `json:"total_users"`
	NewUsersThisWeek int64   `json:"new_users_this_week"`
}

func (q *Queries) GetAdminMetrics(ctx context.Context) (GetAdminMetricsRow, error) {
	row := q.db.QueryRow(ctx, getAdminMetrics)
	var i GetAdminMetricsRow
	err := row.Scan(&i.Mrr, &i.TotalUsers, &i.NewUsersThisWeek)
	return i, err
}

const getFailedJobs24h = `-- name: GetFailedJobs24h :many
SELECT 
    pj.id,
    pj.file_id,
    pj.job_type::text as job_type,
    COALESCE(pj.error_message, 'Unknown error') as error,
    COALESCE(pj.completed_at, pj.created_at) as failed_at,
    (pj.attempts < 3) as can_retry
FROM processing_jobs pj
WHERE pj.status = 'failed'
    AND pj.created_at >= NOW() - INTERVAL '24 hours'
ORDER BY failed_at DESC
LIMIT 20
`

type GetFailedJobs24hRow struct {
	ID       pgtype.UUID        `json:"id"`
	FileID   pgtype.UUID        `json:"file_id"`
	JobType  string             `json:"job_type"`
	Error    string             `json:"error"`
	FailedAt pgtype.Timestamptz `json:"failed_at"`
	CanRetry bool               `json:"can_retry"`
}

func (q *Queries) GetFailedJobs24h(ctx context.Context) ([]GetFailedJobs24hRow, error) {
	rows, err := q.db.Query(ctx, getFailedJobs24h)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFailedJobs24hRow
	for rows.Next() {
		var i GetFailedJobs24hRow
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.JobType,
			&i.Error,
			&i.FailedAt,
			&i.CanRetry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFailedJobsLastHour = `-- name: GetFailedJobsLastHour :one
SELECT COUNT(*)::bigint as count
FROM processing_jobs
WHERE status = 'failed'
    AND created_at >= NOW() - INTERVAL '1 hour'
`

func (q *Queries) GetFailedJobsLastHour(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getFailedJobsLastHour)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getJobStats24h = `-- name: GetJobStats24h :one
SELECT 
    COUNT(*)::bigint as total_jobs,
    COUNT(*) FILTER (WHERE status = 'completed')::bigint as completed,
    COUNT(*) FILTER (WHERE status = 'failed')::bigint as failed
FROM processing_jobs
WHERE created_at >= NOW() - INTERVAL '24 hours'
`

type GetJobStats24hRow struct {
	TotalJobs int64 `json:"total_jobs"`
	Completed int64 `json:"completed"`
	Failed    int64 `json:"failed"`
}

func (q *Queries) GetJobStats24h(ctx context.Context) (GetJobStats24hRow, error) {
	row := q.db.QueryRow(ctx, getJobStats24h)
	var i GetJobStats24hRow
	err := row.Scan(&i.TotalJobs, &i.Completed, &i.Failed)
	return i, err
}

const getMRRHistory = `-- name: GetMRRHistory :many
SELECT 
    DATE(created_at) as date,
    SUM(CASE subscription_tier 
        WHEN 'pro' THEN 19.00 
        WHEN 'enterprise' THEN 99.00 
        ELSE 0 
    END)::float8 as mrr,
    COUNT(*)::bigint as users
FROM users
WHERE created_at >= $1
    AND deleted_at IS NULL
    AND (subscription_status IN ('active', 'trialing') OR subscription_tier = 'free')
GROUP BY DATE(created_at)
ORDER BY date
`

type GetMRRHistoryRow struct {
	Date  pgtype.Date `json:"date"`
	Mrr   float64     `json:"mrr"`
	Users int64       `json:"users"`
}

func (q *Queries) GetMRRHistory(ctx context.Context, createdAt pgtype.Timestamptz) ([]GetMRRHistoryRow, error) {
	rows, err := q.db.Query(ctx, getMRRHistory, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMRRHistoryRow
	for rows.Next() {
		var i GetMRRHistoryRow
		if err := rows.Scan(&i.Date, &i.Mrr, &i.Users); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentSignups = `-- name: GetRecentSignups :many
SELECT 
    email,
    subscription_tier::text as plan,
    created_at
FROM users
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT 10
`

type GetRecentSignupsRow struct {
	Email     string             `json:"email"`
	Plan      string             `json:"plan"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetRecentSignups(ctx context.Context) ([]GetRecentSignupsRow, error) {
	rows, err := q.db.Query(ctx, getRecentSignups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentSignupsRow
	for rows.Next() {
		var i GetRecentSignupsRow
		if err := rows.Scan(&i.Email, &i.Plan, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopUsersByUsage = `-- name: GetTopUsersByUsage :many
SELECT 
    u.email,
    u.subscription_tier::text as plan,
    COUNT(pj.id)::bigint as transforms,
    CASE u.subscription_tier 
        WHEN 'pro' THEN 19.00 
        WHEN 'enterprise' THEN 99.00 
        ELSE 0 
    END::float8 as monthly_rate
FROM users u
JOIN files f ON f.user_id = u.id AND f.deleted_at IS NULL
JOIN processing_jobs pj ON pj.file_id = f.id
WHERE pj.created_at >= DATE_TRUNC('month', NOW())
    AND u.deleted_at IS NULL
GROUP BY u.id, u.email, u.subscription_tier
ORDER BY transforms DESC
LIMIT 10
`

type GetTopUsersByUsageRow struct {
	Email       string  `json:"email"`
	Plan        string  `json:"plan"`
	Transforms  int64   `json:"transforms"`
	MonthlyRate float64 `json:"monthly_rate"`
}

func (q *Queries) GetTopUsersByUsage(ctx context.Context) ([]GetTopUsersByUsageRow, error) {
	rows, err := q.db.Query(ctx, getTopUsersByUsage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopUsersByUsageRow
	for rows.Next() {
		var i GetTopUsersByUsageRow
		if err := rows.Scan(
			&i.Email,
			&i.Plan,
			&i.Transforms,
			&i.MonthlyRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalFilesAndStorage = `-- name: GetTotalFilesAndStorage :one
SELECT 
    COUNT(*)::bigint as total_files,
    COALESCE(SUM(size_bytes), 0)::bigint as total_storage_bytes
FROM files
WHERE deleted_at IS NULL
`

type GetTotalFilesAndStorageRow struct {
	TotalFiles        int64 `json:"total_files"`
	TotalStorageBytes int64 `json:"total_storage_bytes"`
}

func (q *Queries) GetTotalFilesAndStorage(ctx context.Context) (GetTotalFilesAndStorageRow, error) {
	row := q.db.QueryRow(ctx, getTotalFilesAndStorage)
	var i GetTotalFilesAndStorageRow
	err := row.Scan(&i.TotalFiles, &i.TotalStorageBytes)
	return i, err
}

const getUsersByPlan = `-- name: GetUsersByPlan :many
SELECT 
    subscription_tier::text as plan,
    COUNT(*)::bigint as count
FROM users
WHERE deleted_at IS NULL
GROUP BY subscription_tier
ORDER BY count DESC
`

type GetUsersByPlanRow struct {
	Plan  string `json:"plan"`
	Count int64  `json:"count"`
}

func (q *Queries) GetUsersByPlan(ctx context.Context) ([]GetUsersByPlanRow, error) {
	rows, err := q.db.Query(ctx, getUsersByPlan)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByPlanRow
	for rows.Next() {
		var i GetUsersByPlanRow
		if err := rows.Scan(&i.Plan, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkerQueueSize = `-- name: GetWorkerQueueSize :one
SELECT COUNT(*)::bigint as size
FROM processing_jobs
WHERE status IN ('pending', 'running')
`

func (q *Queries) GetWorkerQueueSize(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getWorkerQueueSize)
	var size int64
	err := row.Scan(&size)
	return size, err
}

const listJobsAdmin = `-- name: ListJobsAdmin :many
SELECT 
    pj.id,
    pj.file_id,
    pj.job_type::text as job_type,
    pj.status::text as status,
    pj.priority,
    pj.attempts,
    COALESCE(pj.error_message, '') as error_message,
    pj.created_at,
    pj.started_at,
    pj.completed_at,
    f.filename
FROM processing_jobs pj
LEFT JOIN files f ON f.id = pj.file_id
WHERE ($3::text IS NULL OR pj.status::text = $3)
ORDER BY pj.created_at DESC
LIMIT $1 OFFSET $2
`

type ListJobsAdminParams struct {
	Limit  int32   `json:"limit"`
	Offset int32   `json:"offset"`
	Status *string `json:"status"`
}

type ListJobsAdminRow struct {
	ID           pgtype.UUID        `json:"id"`
	FileID       pgtype.UUID        `json:"file_id"`
	JobType      string             `json:"job_type"`
	Status       string             `json:"status"`
	Priority     int32              `json:"priority"`
	Attempts     int32              `json:"attempts"`
	ErrorMessage string             `json:"error_message"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	StartedAt    pgtype.Timestamptz `json:"started_at"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
	Filename     *string            `json:"filename"`
}

func (q *Queries) ListJobsAdmin(ctx context.Context, arg ListJobsAdminParams) ([]ListJobsAdminRow, error) {
	rows, err := q.db.Query(ctx, listJobsAdmin, arg.Limit, arg.Offset, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListJobsAdminRow
	for rows.Next() {
		var i ListJobsAdminRow
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.JobType,
			&i.Status,
			&i.Priority,
			&i.Attempts,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Filename,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const retryFailedJob = `-- name: RetryFailedJob :exec
UPDATE processing_jobs
SET status = 'pending', error_message = NULL, attempts = 0
WHERE id = $1 AND status = 'failed'
`

func (q *Queries) RetryFailedJob(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, retryFailedJob, id)
	return err
}
