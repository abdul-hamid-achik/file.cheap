// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: admin_analytics.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countJobsAdmin = `-- name: CountJobsAdmin :one
SELECT COUNT(*)::bigint as total
FROM processing_jobs
WHERE ($1::text IS NULL OR status::text = $1)
`

func (q *Queries) CountJobsAdmin(ctx context.Context, status *string) (int64, error) {
	row := q.db.QueryRow(ctx, countJobsAdmin, status)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getAdminMetrics = `-- name: GetAdminMetrics :one
SELECT
    COALESCE(
        SUM(CASE subscription_tier 
            WHEN 'pro' THEN 19.00 
            WHEN 'enterprise' THEN 99.00 
            ELSE 0 
        END), 0
    )::float8 as mrr,
    COUNT(*)::bigint as total_users,
    COUNT(*) FILTER (
        WHERE created_at >= NOW() - INTERVAL '7 days'
    )::bigint as new_users_this_week
FROM users
WHERE deleted_at IS NULL 
    AND (subscription_status IN ('active', 'trialing') OR subscription_tier = 'free')
`

type GetAdminMetricsRow struct {
	Mrr              float64 `json:"mrr"`
	TotalUsers       int64   `json:"total_users"`
	NewUsersThisWeek int64   `json:"new_users_this_week"`
}

func (q *Queries) GetAdminMetrics(ctx context.Context) (GetAdminMetricsRow, error) {
	row := q.db.QueryRow(ctx, getAdminMetrics)
	var i GetAdminMetricsRow
	err := row.Scan(&i.Mrr, &i.TotalUsers, &i.NewUsersThisWeek)
	return i, err
}

const getAlertConfig = `-- name: GetAlertConfig :many
SELECT id, metric_name, threshold_value, enabled, updated_at, created_at FROM admin_alert_config ORDER BY metric_name
`

func (q *Queries) GetAlertConfig(ctx context.Context) ([]AdminAlertConfig, error) {
	rows, err := q.db.Query(ctx, getAlertConfig)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminAlertConfig
	for rows.Next() {
		var i AdminAlertConfig
		if err := rows.Scan(
			&i.ID,
			&i.MetricName,
			&i.ThresholdValue,
			&i.Enabled,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChurnMetrics = `-- name: GetChurnMetrics :one
WITH monthly_stats AS (
    SELECT
        COUNT(*) FILTER (
            WHERE subscription_status = 'canceled'
            AND updated_at >= DATE_TRUNC('month', NOW())
        )::bigint as churned_this_month,
        COUNT(*) FILTER (
            WHERE subscription_status IN ('active', 'trialing')
            AND created_at < DATE_TRUNC('month', NOW())
        )::bigint as active_start_of_month,
        COUNT(*) FILTER (
            WHERE subscription_status IN ('active', 'trialing')
        )::bigint as current_active,
        COUNT(*) FILTER (
            WHERE subscription_status = 'canceled'
            AND updated_at >= NOW() - INTERVAL '30 days'
        )::bigint as churned_30d
    FROM users
    WHERE deleted_at IS NULL
)
SELECT
    churned_this_month,
    churned_30d,
    current_active,
    CASE
        WHEN active_start_of_month > 0
        THEN (churned_this_month::float8 / active_start_of_month::float8 * 100)
        ELSE 0
    END as monthly_churn_rate,
    CASE
        WHEN active_start_of_month > 0
        THEN ((active_start_of_month - churned_this_month)::float8 / active_start_of_month::float8 * 100)
        ELSE 100
    END as retention_rate
FROM monthly_stats
`

type GetChurnMetricsRow struct {
	ChurnedThisMonth int64 `json:"churned_this_month"`
	Churned30d       int64 `json:"churned_30d"`
	CurrentActive    int64 `json:"current_active"`
	MonthlyChurnRate int32 `json:"monthly_churn_rate"`
	RetentionRate    int32 `json:"retention_rate"`
}

func (q *Queries) GetChurnMetrics(ctx context.Context) (GetChurnMetricsRow, error) {
	row := q.db.QueryRow(ctx, getChurnMetrics)
	var i GetChurnMetricsRow
	err := row.Scan(
		&i.ChurnedThisMonth,
		&i.Churned30d,
		&i.CurrentActive,
		&i.MonthlyChurnRate,
		&i.RetentionRate,
	)
	return i, err
}

const getCohortRetention = `-- name: GetCohortRetention :many
WITH cohorts AS (
    SELECT
        id,
        DATE_TRUNC('month', created_at)::date as cohort_month,
        created_at,
        CASE
            WHEN subscription_status IN ('active', 'trialing') THEN true
            ELSE false
        END as is_active
    FROM users
    WHERE deleted_at IS NULL
        AND created_at >= NOW() - INTERVAL '6 months'
),
cohort_sizes AS (
    SELECT
        cohort_month,
        COUNT(*) as cohort_size
    FROM cohorts
    GROUP BY cohort_month
),
retention AS (
    SELECT
        c.cohort_month,
        EXTRACT(MONTH FROM AGE(DATE_TRUNC('month', NOW()), c.cohort_month))::int as months_since,
        COUNT(*) FILTER (WHERE c.is_active) as retained
    FROM cohorts c
    GROUP BY c.cohort_month, months_since
)
SELECT
    r.cohort_month,
    cs.cohort_size::bigint,
    r.months_since::int,
    r.retained::bigint,
    CASE
        WHEN cs.cohort_size > 0
        THEN (r.retained::float8 / cs.cohort_size::float8 * 100)
        ELSE 0
    END as retention_pct
FROM retention r
JOIN cohort_sizes cs ON cs.cohort_month = r.cohort_month
ORDER BY r.cohort_month DESC, r.months_since
`

type GetCohortRetentionRow struct {
	CohortMonth  pgtype.Date `json:"cohort_month"`
	CsCohortSize int64       `json:"cs_cohort_size"`
	RMonthsSince int32       `json:"r_months_since"`
	RRetained    int64       `json:"r_retained"`
	RetentionPct int32       `json:"retention_pct"`
}

func (q *Queries) GetCohortRetention(ctx context.Context) ([]GetCohortRetentionRow, error) {
	rows, err := q.db.Query(ctx, getCohortRetention)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCohortRetentionRow
	for rows.Next() {
		var i GetCohortRetentionRow
		if err := rows.Scan(
			&i.CohortMonth,
			&i.CsCohortSize,
			&i.RMonthsSince,
			&i.RRetained,
			&i.RetentionPct,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFailedJobs24h = `-- name: GetFailedJobs24h :many
SELECT 
    pj.id,
    pj.file_id,
    pj.job_type::text as job_type,
    COALESCE(pj.error_message, 'Unknown error') as error,
    COALESCE(pj.completed_at, pj.created_at) as failed_at,
    (pj.attempts < 3) as can_retry
FROM processing_jobs pj
WHERE pj.status = 'failed'
    AND pj.created_at >= NOW() - INTERVAL '24 hours'
ORDER BY failed_at DESC
LIMIT 20
`

type GetFailedJobs24hRow struct {
	ID       pgtype.UUID        `json:"id"`
	FileID   pgtype.UUID        `json:"file_id"`
	JobType  string             `json:"job_type"`
	Error    string             `json:"error"`
	FailedAt pgtype.Timestamptz `json:"failed_at"`
	CanRetry bool               `json:"can_retry"`
}

func (q *Queries) GetFailedJobs24h(ctx context.Context) ([]GetFailedJobs24hRow, error) {
	rows, err := q.db.Query(ctx, getFailedJobs24h)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFailedJobs24hRow
	for rows.Next() {
		var i GetFailedJobs24hRow
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.JobType,
			&i.Error,
			&i.FailedAt,
			&i.CanRetry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFailedJobsLastHour = `-- name: GetFailedJobsLastHour :one
SELECT COUNT(*)::bigint as count
FROM processing_jobs
WHERE status = 'failed'
    AND created_at >= NOW() - INTERVAL '1 hour'
`

func (q *Queries) GetFailedJobsLastHour(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getFailedJobsLastHour)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getJobStats24h = `-- name: GetJobStats24h :one
SELECT 
    COUNT(*)::bigint as total_jobs,
    COUNT(*) FILTER (WHERE status = 'completed')::bigint as completed,
    COUNT(*) FILTER (WHERE status = 'failed')::bigint as failed
FROM processing_jobs
WHERE created_at >= NOW() - INTERVAL '24 hours'
`

type GetJobStats24hRow struct {
	TotalJobs int64 `json:"total_jobs"`
	Completed int64 `json:"completed"`
	Failed    int64 `json:"failed"`
}

func (q *Queries) GetJobStats24h(ctx context.Context) (GetJobStats24hRow, error) {
	row := q.db.QueryRow(ctx, getJobStats24h)
	var i GetJobStats24hRow
	err := row.Scan(&i.TotalJobs, &i.Completed, &i.Failed)
	return i, err
}

const getMRRHistory = `-- name: GetMRRHistory :many
SELECT 
    DATE(created_at) as date,
    SUM(CASE subscription_tier 
        WHEN 'pro' THEN 19.00 
        WHEN 'enterprise' THEN 99.00 
        ELSE 0 
    END)::float8 as mrr,
    COUNT(*)::bigint as users
FROM users
WHERE created_at >= $1
    AND deleted_at IS NULL
    AND (subscription_status IN ('active', 'trialing') OR subscription_tier = 'free')
GROUP BY DATE(created_at)
ORDER BY date
`

type GetMRRHistoryRow struct {
	Date  pgtype.Date `json:"date"`
	Mrr   float64     `json:"mrr"`
	Users int64       `json:"users"`
}

func (q *Queries) GetMRRHistory(ctx context.Context, createdAt pgtype.Timestamptz) ([]GetMRRHistoryRow, error) {
	rows, err := q.db.Query(ctx, getMRRHistory, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMRRHistoryRow
	for rows.Next() {
		var i GetMRRHistoryRow
		if err := rows.Scan(&i.Date, &i.Mrr, &i.Users); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNRR = `-- name: GetNRR :one
WITH previous_month AS (
    SELECT COALESCE(SUM(
        CASE subscription_tier
            WHEN 'pro' THEN 19.00
            WHEN 'enterprise' THEN 99.00
            ELSE 0
        END
    ), 0)::float8 as mrr
    FROM users
    WHERE deleted_at IS NULL
        AND subscription_status IN ('active', 'trialing')
        AND created_at < DATE_TRUNC('month', NOW())
),
current_month AS (
    SELECT COALESCE(SUM(
        CASE subscription_tier
            WHEN 'pro' THEN 19.00
            WHEN 'enterprise' THEN 99.00
            ELSE 0
        END
    ), 0)::float8 as mrr
    FROM users
    WHERE deleted_at IS NULL
        AND subscription_status IN ('active', 'trialing')
)
SELECT
    p.mrr as previous_mrr,
    c.mrr as current_mrr,
    CASE
        WHEN p.mrr > 0
        THEN (c.mrr / p.mrr * 100)
        ELSE 100
    END as nrr_percent
FROM previous_month p, current_month c
`

type GetNRRRow struct {
	PreviousMrr float64 `json:"previous_mrr"`
	CurrentMrr  float64 `json:"current_mrr"`
	NrrPercent  int32   `json:"nrr_percent"`
}

func (q *Queries) GetNRR(ctx context.Context) (GetNRRRow, error) {
	row := q.db.QueryRow(ctx, getNRR)
	var i GetNRRRow
	err := row.Scan(&i.PreviousMrr, &i.CurrentMrr, &i.NrrPercent)
	return i, err
}

const getRecentSignups = `-- name: GetRecentSignups :many
SELECT 
    email,
    subscription_tier::text as plan,
    created_at
FROM users
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT 10
`

type GetRecentSignupsRow struct {
	Email     string             `json:"email"`
	Plan      string             `json:"plan"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetRecentSignups(ctx context.Context) ([]GetRecentSignupsRow, error) {
	rows, err := q.db.Query(ctx, getRecentSignups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentSignupsRow
	for rows.Next() {
		var i GetRecentSignupsRow
		if err := rows.Scan(&i.Email, &i.Plan, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevenueMetrics = `-- name: GetRevenueMetrics :one
WITH revenue_stats AS (
    SELECT
        COUNT(*) FILTER (WHERE subscription_status IN ('active', 'trialing'))::bigint as paying_users,
        COALESCE(SUM(
            CASE subscription_tier
                WHEN 'pro' THEN 19.00
                WHEN 'enterprise' THEN 99.00
                ELSE 0
            END
        ) FILTER (WHERE subscription_status IN ('active', 'trialing')), 0)::float8 as mrr
    FROM users
    WHERE deleted_at IS NULL
),
churn_stats AS (
    SELECT
        COUNT(*) FILTER (
            WHERE subscription_status = 'canceled'
            AND updated_at >= DATE_TRUNC('month', NOW())
        )::bigint as churned,
        COUNT(*) FILTER (
            WHERE subscription_status IN ('active', 'trialing')
            AND created_at < DATE_TRUNC('month', NOW())
        )::bigint as start_count
    FROM users
    WHERE deleted_at IS NULL
)
SELECT
    r.mrr,
    CASE
        WHEN r.paying_users > 0
        THEN r.mrr / r.paying_users::float8
        ELSE 0
    END as arpu,
    CASE
        WHEN c.start_count > 0 AND c.churned > 0
        THEN (r.mrr / r.paying_users::float8) / (c.churned::float8 / c.start_count::float8)
        ELSE r.mrr * 24
    END as estimated_ltv,
    r.paying_users,
    CASE r.paying_users
        WHEN 0 THEN 0
        ELSE (r.mrr * 12)::float8
    END as arr
FROM revenue_stats r, churn_stats c
`

type GetRevenueMetricsRow struct {
	Mrr          float64     `json:"mrr"`
	Arpu         int32       `json:"arpu"`
	EstimatedLtv interface{} `json:"estimated_ltv"`
	PayingUsers  int64       `json:"paying_users"`
	Arr          float64     `json:"arr"`
}

func (q *Queries) GetRevenueMetrics(ctx context.Context) (GetRevenueMetricsRow, error) {
	row := q.db.QueryRow(ctx, getRevenueMetrics)
	var i GetRevenueMetricsRow
	err := row.Scan(
		&i.Mrr,
		&i.Arpu,
		&i.EstimatedLtv,
		&i.PayingUsers,
		&i.Arr,
	)
	return i, err
}

const getTopUsersByUsage = `-- name: GetTopUsersByUsage :many
SELECT 
    u.email,
    u.subscription_tier::text as plan,
    COUNT(pj.id)::bigint as transforms,
    CASE u.subscription_tier 
        WHEN 'pro' THEN 19.00 
        WHEN 'enterprise' THEN 99.00 
        ELSE 0 
    END::float8 as monthly_rate
FROM users u
JOIN files f ON f.user_id = u.id AND f.deleted_at IS NULL
JOIN processing_jobs pj ON pj.file_id = f.id
WHERE pj.created_at >= DATE_TRUNC('month', NOW())
    AND u.deleted_at IS NULL
GROUP BY u.id, u.email, u.subscription_tier
ORDER BY transforms DESC
LIMIT 10
`

type GetTopUsersByUsageRow struct {
	Email       string  `json:"email"`
	Plan        string  `json:"plan"`
	Transforms  int64   `json:"transforms"`
	MonthlyRate float64 `json:"monthly_rate"`
}

func (q *Queries) GetTopUsersByUsage(ctx context.Context) ([]GetTopUsersByUsageRow, error) {
	rows, err := q.db.Query(ctx, getTopUsersByUsage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopUsersByUsageRow
	for rows.Next() {
		var i GetTopUsersByUsageRow
		if err := rows.Scan(
			&i.Email,
			&i.Plan,
			&i.Transforms,
			&i.MonthlyRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalFilesAndStorage = `-- name: GetTotalFilesAndStorage :one
SELECT 
    COUNT(*)::bigint as total_files,
    COALESCE(SUM(size_bytes), 0)::bigint as total_storage_bytes
FROM files
WHERE deleted_at IS NULL
`

type GetTotalFilesAndStorageRow struct {
	TotalFiles        int64 `json:"total_files"`
	TotalStorageBytes int64 `json:"total_storage_bytes"`
}

func (q *Queries) GetTotalFilesAndStorage(ctx context.Context) (GetTotalFilesAndStorageRow, error) {
	row := q.db.QueryRow(ctx, getTotalFilesAndStorage)
	var i GetTotalFilesAndStorageRow
	err := row.Scan(&i.TotalFiles, &i.TotalStorageBytes)
	return i, err
}

const getUsersByPlan = `-- name: GetUsersByPlan :many
SELECT 
    subscription_tier::text as plan,
    COUNT(*)::bigint as count
FROM users
WHERE deleted_at IS NULL
GROUP BY subscription_tier
ORDER BY count DESC
`

type GetUsersByPlanRow struct {
	Plan  string `json:"plan"`
	Count int64  `json:"count"`
}

func (q *Queries) GetUsersByPlan(ctx context.Context) ([]GetUsersByPlanRow, error) {
	rows, err := q.db.Query(ctx, getUsersByPlan)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByPlanRow
	for rows.Next() {
		var i GetUsersByPlanRow
		if err := rows.Scan(&i.Plan, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkerQueueSize = `-- name: GetWorkerQueueSize :one
SELECT COUNT(*)::bigint as size
FROM processing_jobs
WHERE status IN ('pending', 'running')
`

func (q *Queries) GetWorkerQueueSize(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getWorkerQueueSize)
	var size int64
	err := row.Scan(&size)
	return size, err
}

const listJobsAdmin = `-- name: ListJobsAdmin :many
SELECT 
    pj.id,
    pj.file_id,
    pj.job_type::text as job_type,
    pj.status::text as status,
    pj.priority,
    pj.attempts,
    COALESCE(pj.error_message, '') as error_message,
    pj.created_at,
    pj.started_at,
    pj.completed_at,
    f.filename
FROM processing_jobs pj
LEFT JOIN files f ON f.id = pj.file_id
WHERE ($3::text IS NULL OR pj.status::text = $3)
ORDER BY pj.created_at DESC
LIMIT $1 OFFSET $2
`

type ListJobsAdminParams struct {
	Limit  int32   `json:"limit"`
	Offset int32   `json:"offset"`
	Status *string `json:"status"`
}

type ListJobsAdminRow struct {
	ID           pgtype.UUID        `json:"id"`
	FileID       pgtype.UUID        `json:"file_id"`
	JobType      string             `json:"job_type"`
	Status       string             `json:"status"`
	Priority     int32              `json:"priority"`
	Attempts     int32              `json:"attempts"`
	ErrorMessage string             `json:"error_message"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	StartedAt    pgtype.Timestamptz `json:"started_at"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
	Filename     *string            `json:"filename"`
}

func (q *Queries) ListJobsAdmin(ctx context.Context, arg ListJobsAdminParams) ([]ListJobsAdminRow, error) {
	rows, err := q.db.Query(ctx, listJobsAdmin, arg.Limit, arg.Offset, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListJobsAdminRow
	for rows.Next() {
		var i ListJobsAdminRow
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.JobType,
			&i.Status,
			&i.Priority,
			&i.Attempts,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Filename,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const retryFailedJob = `-- name: RetryFailedJob :exec
UPDATE processing_jobs
SET status = 'pending', error_message = NULL, attempts = 0
WHERE id = $1 AND status = 'failed'
`

func (q *Queries) RetryFailedJob(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, retryFailedJob, id)
	return err
}

const updateAlertThreshold = `-- name: UpdateAlertThreshold :exec
UPDATE admin_alert_config
SET threshold_value = $2, enabled = $3, updated_at = NOW()
WHERE metric_name = $1
`

type UpdateAlertThresholdParams struct {
	MetricName     string  `json:"metric_name"`
	ThresholdValue float64 `json:"threshold_value"`
	Enabled        *bool   `json:"enabled"`
}

func (q *Queries) UpdateAlertThreshold(ctx context.Context, arg UpdateAlertThresholdParams) error {
	_, err := q.db.Exec(ctx, updateAlertThreshold, arg.MetricName, arg.ThresholdValue, arg.Enabled)
	return err
}
