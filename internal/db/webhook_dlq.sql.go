// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: webhook_dlq.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countWebhookDLQByUser = `-- name: CountWebhookDLQByUser :one
SELECT COUNT(*)
FROM webhook_dlq dlq
JOIN webhooks w ON w.id = dlq.webhook_id
WHERE w.user_id = $1
`

func (q *Queries) CountWebhookDLQByUser(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countWebhookDLQByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWebhookDLQEntry = `-- name: CreateWebhookDLQEntry :one
INSERT INTO webhook_dlq (
    webhook_id,
    delivery_id,
    event_type,
    payload,
    final_error,
    attempts,
    last_response_code,
    last_response_body
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, webhook_id, delivery_id, event_type, payload, final_error, attempts, last_response_code, last_response_body, can_retry, retried_at, created_at
`

type CreateWebhookDLQEntryParams struct {
	WebhookID        pgtype.UUID `json:"webhook_id"`
	DeliveryID       pgtype.UUID `json:"delivery_id"`
	EventType        string      `json:"event_type"`
	Payload          []byte      `json:"payload"`
	FinalError       string      `json:"final_error"`
	Attempts         int32       `json:"attempts"`
	LastResponseCode *int32      `json:"last_response_code"`
	LastResponseBody *string     `json:"last_response_body"`
}

func (q *Queries) CreateWebhookDLQEntry(ctx context.Context, arg CreateWebhookDLQEntryParams) (WebhookDlq, error) {
	row := q.db.QueryRow(ctx, createWebhookDLQEntry,
		arg.WebhookID,
		arg.DeliveryID,
		arg.EventType,
		arg.Payload,
		arg.FinalError,
		arg.Attempts,
		arg.LastResponseCode,
		arg.LastResponseBody,
	)
	var i WebhookDlq
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.DeliveryID,
		&i.EventType,
		&i.Payload,
		&i.FinalError,
		&i.Attempts,
		&i.LastResponseCode,
		&i.LastResponseBody,
		&i.CanRetry,
		&i.RetriedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOldDLQEntries = `-- name: DeleteOldDLQEntries :exec
DELETE FROM webhook_dlq
WHERE created_at < NOW() - INTERVAL '30 days'
`

func (q *Queries) DeleteOldDLQEntries(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteOldDLQEntries)
	return err
}

const deleteWebhookDLQEntry = `-- name: DeleteWebhookDLQEntry :exec
DELETE FROM webhook_dlq
WHERE id = $1
`

func (q *Queries) DeleteWebhookDLQEntry(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteWebhookDLQEntry, id)
	return err
}

const getWebhookDLQEntry = `-- name: GetWebhookDLQEntry :one
SELECT id, webhook_id, delivery_id, event_type, payload, final_error, attempts, last_response_code, last_response_body, can_retry, retried_at, created_at FROM webhook_dlq
WHERE id = $1
`

func (q *Queries) GetWebhookDLQEntry(ctx context.Context, id pgtype.UUID) (WebhookDlq, error) {
	row := q.db.QueryRow(ctx, getWebhookDLQEntry, id)
	var i WebhookDlq
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.DeliveryID,
		&i.EventType,
		&i.Payload,
		&i.FinalError,
		&i.Attempts,
		&i.LastResponseCode,
		&i.LastResponseBody,
		&i.CanRetry,
		&i.RetriedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listRetryableWebhookDLQ = `-- name: ListRetryableWebhookDLQ :many
SELECT dlq.id, dlq.webhook_id, dlq.delivery_id, dlq.event_type, dlq.payload, dlq.final_error, dlq.attempts, dlq.last_response_code, dlq.last_response_body, dlq.can_retry, dlq.retried_at, dlq.created_at
FROM webhook_dlq dlq
JOIN webhooks w ON w.id = dlq.webhook_id
WHERE w.user_id = $1 AND dlq.can_retry = true
ORDER BY dlq.created_at DESC
LIMIT $2
`

type ListRetryableWebhookDLQParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
}

func (q *Queries) ListRetryableWebhookDLQ(ctx context.Context, arg ListRetryableWebhookDLQParams) ([]WebhookDlq, error) {
	rows, err := q.db.Query(ctx, listRetryableWebhookDLQ, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WebhookDlq
	for rows.Next() {
		var i WebhookDlq
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.DeliveryID,
			&i.EventType,
			&i.Payload,
			&i.FinalError,
			&i.Attempts,
			&i.LastResponseCode,
			&i.LastResponseBody,
			&i.CanRetry,
			&i.RetriedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhookDLQByUser = `-- name: ListWebhookDLQByUser :many
SELECT dlq.id, dlq.webhook_id, dlq.delivery_id, dlq.event_type, dlq.payload, dlq.final_error, dlq.attempts, dlq.last_response_code, dlq.last_response_body, dlq.can_retry, dlq.retried_at, dlq.created_at
FROM webhook_dlq dlq
JOIN webhooks w ON w.id = dlq.webhook_id
WHERE w.user_id = $1
ORDER BY dlq.created_at DESC
LIMIT $2 OFFSET $3
`

type ListWebhookDLQByUserParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListWebhookDLQByUser(ctx context.Context, arg ListWebhookDLQByUserParams) ([]WebhookDlq, error) {
	rows, err := q.db.Query(ctx, listWebhookDLQByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WebhookDlq
	for rows.Next() {
		var i WebhookDlq
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.DeliveryID,
			&i.EventType,
			&i.Payload,
			&i.FinalError,
			&i.Attempts,
			&i.LastResponseCode,
			&i.LastResponseBody,
			&i.CanRetry,
			&i.RetriedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhookDLQByWebhook = `-- name: ListWebhookDLQByWebhook :many
SELECT id, webhook_id, delivery_id, event_type, payload, final_error, attempts, last_response_code, last_response_body, can_retry, retried_at, created_at FROM webhook_dlq
WHERE webhook_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListWebhookDLQByWebhookParams struct {
	WebhookID pgtype.UUID `json:"webhook_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) ListWebhookDLQByWebhook(ctx context.Context, arg ListWebhookDLQByWebhookParams) ([]WebhookDlq, error) {
	rows, err := q.db.Query(ctx, listWebhookDLQByWebhook, arg.WebhookID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WebhookDlq
	for rows.Next() {
		var i WebhookDlq
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.DeliveryID,
			&i.EventType,
			&i.Payload,
			&i.FinalError,
			&i.Attempts,
			&i.LastResponseCode,
			&i.LastResponseBody,
			&i.CanRetry,
			&i.RetriedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markWebhookDLQRetried = `-- name: MarkWebhookDLQRetried :exec
UPDATE webhook_dlq
SET can_retry = false, retried_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkWebhookDLQRetried(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markWebhookDLQRetried, id)
	return err
}
