// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analytics.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getDailyUsage = `-- name: GetDailyUsage :many
SELECT 
    dates.date::date as date,
    COALESCE(file_counts.uploads, 0)::bigint as uploads,
    COALESCE(job_counts.transforms, 0)::bigint as transforms
FROM (
    SELECT generate_series($2::date, CURRENT_DATE, '1 day'::interval)::date as date
) dates
LEFT JOIN (
    SELECT DATE(f2.created_at) as day, COUNT(*) as uploads
    FROM files f2
    WHERE f2.user_id = $1 AND f2.created_at >= $2 AND f2.deleted_at IS NULL
    GROUP BY DATE(f2.created_at)
) file_counts ON dates.date = file_counts.day
LEFT JOIN (
    SELECT DATE(pj.created_at) as day, COUNT(*) as transforms
    FROM processing_jobs pj
    JOIN files f3 ON f3.id = pj.file_id
    WHERE f3.user_id = $1 AND pj.created_at >= $2 AND f3.deleted_at IS NULL
    GROUP BY DATE(pj.created_at)
) job_counts ON dates.date = job_counts.day
ORDER BY dates.date
`

type GetDailyUsageParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 pgtype.Date `json:"column_2"`
}

type GetDailyUsageRow struct {
	Date       pgtype.Date `json:"date"`
	Uploads    int64       `json:"uploads"`
	Transforms int64       `json:"transforms"`
}

func (q *Queries) GetDailyUsage(ctx context.Context, arg GetDailyUsageParams) ([]GetDailyUsageRow, error) {
	rows, err := q.db.Query(ctx, getDailyUsage, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailyUsageRow
	for rows.Next() {
		var i GetDailyUsageRow
		if err := rows.Scan(&i.Date, &i.Uploads, &i.Transforms); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentActivity = `-- name: GetRecentActivity :many
SELECT id, type, message, status, created_at FROM (
    SELECT 
        f.id::text as id,
        'upload' as type,
        f.filename || ' uploaded' as message,
        'success' as status,
        f.created_at as created_at
    FROM files f
    WHERE f.user_id = $1 AND f.deleted_at IS NULL
    
    UNION ALL
    
    SELECT 
        pj.id::text as id,
        'transform' as type,
        f.filename || ' ' || pj.job_type::text || 
            CASE pj.status 
                WHEN 'completed' THEN ' completed'
                WHEN 'failed' THEN ' failed'
                WHEN 'running' THEN ' processing'
                ELSE ' queued'
            END as message,
        CASE pj.status
            WHEN 'completed' THEN 'success'
            WHEN 'failed' THEN 'error'
            ELSE 'warning'
        END as status,
        COALESCE(pj.completed_at, pj.created_at) as created_at
    FROM processing_jobs pj
    JOIN files f ON f.id = pj.file_id
    WHERE f.user_id = $1 AND f.deleted_at IS NULL
    
    UNION ALL
    
    SELECT 
        b.id::text as id,
        'batch' as type,
        'Batch ' || LEFT(b.id::text, 8) || 
            CASE b.status
                WHEN 'completed' THEN ' completed (' || b.completed_files || ' files)'
                WHEN 'failed' THEN ' failed'
                WHEN 'partial' THEN ' partially completed'
                ELSE ' processing'
            END as message,
        CASE b.status
            WHEN 'completed' THEN 'success'
            WHEN 'failed' THEN 'error'
            ELSE 'warning'
        END as status,
        COALESCE(b.completed_at, b.created_at) as created_at
    FROM batch_operations b
    WHERE b.user_id = $1
) activity
ORDER BY created_at DESC
LIMIT 20
`

type GetRecentActivityRow struct {
	ID        string             `json:"id"`
	Type      string             `json:"type"`
	Message   interface{}        `json:"message"`
	Status    string             `json:"status"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetRecentActivity(ctx context.Context, userID pgtype.UUID) ([]GetRecentActivityRow, error) {
	rows, err := q.db.Query(ctx, getRecentActivity, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentActivityRow
	for rows.Next() {
		var i GetRecentActivityRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Message,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopFilesByTransforms = `-- name: GetTopFilesByTransforms :many
SELECT 
    f.id as file_id,
    f.filename,
    COUNT(pj.id)::bigint as transforms
FROM files f
JOIN processing_jobs pj ON pj.file_id = f.id
WHERE f.user_id = $1 
    AND pj.created_at >= DATE_TRUNC('month', NOW())
    AND f.deleted_at IS NULL
GROUP BY f.id, f.filename
ORDER BY transforms DESC
LIMIT 10
`

type GetTopFilesByTransformsRow struct {
	FileID     pgtype.UUID `json:"file_id"`
	Filename   string      `json:"filename"`
	Transforms int64       `json:"transforms"`
}

func (q *Queries) GetTopFilesByTransforms(ctx context.Context, userID pgtype.UUID) ([]GetTopFilesByTransformsRow, error) {
	rows, err := q.db.Query(ctx, getTopFilesByTransforms, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopFilesByTransformsRow
	for rows.Next() {
		var i GetTopFilesByTransformsRow
		if err := rows.Scan(&i.FileID, &i.Filename, &i.Transforms); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalStorageByUser = `-- name: GetTotalStorageByUser :one
SELECT COALESCE(SUM(size_bytes), 0)::bigint as total_bytes
FROM files
WHERE user_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetTotalStorageByUser(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalStorageByUser, userID)
	var total_bytes int64
	err := row.Scan(&total_bytes)
	return total_bytes, err
}

const getTransformBreakdown = `-- name: GetTransformBreakdown :many
SELECT 
    pj.job_type::text as type,
    COUNT(*)::bigint as count
FROM processing_jobs pj
JOIN files f ON f.id = pj.file_id
WHERE f.user_id = $1 
    AND pj.created_at >= DATE_TRUNC('month', NOW())
    AND pj.status = 'completed'
    AND f.deleted_at IS NULL
GROUP BY pj.job_type
ORDER BY count DESC
`

type GetTransformBreakdownRow struct {
	Type  string `json:"type"`
	Count int64  `json:"count"`
}

func (q *Queries) GetTransformBreakdown(ctx context.Context, userID pgtype.UUID) ([]GetTransformBreakdownRow, error) {
	rows, err := q.db.Query(ctx, getTransformBreakdown, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransformBreakdownRow
	for rows.Next() {
		var i GetTransformBreakdownRow
		if err := rows.Scan(&i.Type, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserUsageStats = `-- name: GetUserUsageStats :one
SELECT 
    COALESCE(COUNT(DISTINCT f.id) FILTER (WHERE f.deleted_at IS NULL), 0)::bigint as files_used,
    u.files_limit as files_limit,
    COALESCE(u.transformations_count, 0) as transforms_used,
    u.transformations_limit as transforms_limit,
    COALESCE(SUM(f.size_bytes) FILTER (WHERE f.deleted_at IS NULL), 0)::bigint as storage_used_bytes,
    u.subscription_tier as plan_name,
    COALESCE(u.subscription_period_end, u.transformations_reset_at) as plan_renews_at
FROM users u
LEFT JOIN files f ON f.user_id = u.id
WHERE u.id = $1 AND u.deleted_at IS NULL
GROUP BY u.id
`

type GetUserUsageStatsRow struct {
	FilesUsed        int64              `json:"files_used"`
	FilesLimit       int32              `json:"files_limit"`
	TransformsUsed   int32              `json:"transforms_used"`
	TransformsLimit  int32              `json:"transforms_limit"`
	StorageUsedBytes int64              `json:"storage_used_bytes"`
	PlanName         SubscriptionTier   `json:"plan_name"`
	PlanRenewsAt     pgtype.Timestamptz `json:"plan_renews_at"`
}

func (q *Queries) GetUserUsageStats(ctx context.Context, id pgtype.UUID) (GetUserUsageStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserUsageStats, id)
	var i GetUserUsageStatsRow
	err := row.Scan(
		&i.FilesUsed,
		&i.FilesLimit,
		&i.TransformsUsed,
		&i.TransformsLimit,
		&i.StorageUsedBytes,
		&i.PlanName,
		&i.PlanRenewsAt,
	)
	return i, err
}
