// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: enterprise.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEnterpriseInquiries = `-- name: CountEnterpriseInquiries :one
SELECT COUNT(*) FROM enterprise_inquiries
`

func (q *Queries) CountEnterpriseInquiries(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countEnterpriseInquiries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEnterpriseInquiriesByStatus = `-- name: CountEnterpriseInquiriesByStatus :one
SELECT COUNT(*) FROM enterprise_inquiries
WHERE status = $1
`

func (q *Queries) CountEnterpriseInquiriesByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRow(ctx, countEnterpriseInquiriesByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEnterpriseInquiry = `-- name: CreateEnterpriseInquiry :one
INSERT INTO enterprise_inquiries (
    user_id, company_name, contact_name, email, phone,
    company_size, estimated_usage, message
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, user_id, company_name, contact_name, email, phone, company_size, estimated_usage, message, status, admin_notes, processed_at, processed_by, created_at
`

type CreateEnterpriseInquiryParams struct {
	UserID         pgtype.UUID `json:"user_id"`
	CompanyName    string      `json:"company_name"`
	ContactName    string      `json:"contact_name"`
	Email          string      `json:"email"`
	Phone          *string     `json:"phone"`
	CompanySize    string      `json:"company_size"`
	EstimatedUsage string      `json:"estimated_usage"`
	Message        string      `json:"message"`
}

func (q *Queries) CreateEnterpriseInquiry(ctx context.Context, arg CreateEnterpriseInquiryParams) (EnterpriseInquiry, error) {
	row := q.db.QueryRow(ctx, createEnterpriseInquiry,
		arg.UserID,
		arg.CompanyName,
		arg.ContactName,
		arg.Email,
		arg.Phone,
		arg.CompanySize,
		arg.EstimatedUsage,
		arg.Message,
	)
	var i EnterpriseInquiry
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyName,
		&i.ContactName,
		&i.Email,
		&i.Phone,
		&i.CompanySize,
		&i.EstimatedUsage,
		&i.Message,
		&i.Status,
		&i.AdminNotes,
		&i.ProcessedAt,
		&i.ProcessedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getEnterpriseInquiry = `-- name: GetEnterpriseInquiry :one
SELECT id, user_id, company_name, contact_name, email, phone, company_size, estimated_usage, message, status, admin_notes, processed_at, processed_by, created_at FROM enterprise_inquiries
WHERE id = $1
`

func (q *Queries) GetEnterpriseInquiry(ctx context.Context, id pgtype.UUID) (EnterpriseInquiry, error) {
	row := q.db.QueryRow(ctx, getEnterpriseInquiry, id)
	var i EnterpriseInquiry
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyName,
		&i.ContactName,
		&i.Email,
		&i.Phone,
		&i.CompanySize,
		&i.EstimatedUsage,
		&i.Message,
		&i.Status,
		&i.AdminNotes,
		&i.ProcessedAt,
		&i.ProcessedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getUserEnterpriseInquiry = `-- name: GetUserEnterpriseInquiry :one
SELECT id, user_id, company_name, contact_name, email, phone, company_size, estimated_usage, message, status, admin_notes, processed_at, processed_by, created_at FROM enterprise_inquiries
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetUserEnterpriseInquiry(ctx context.Context, userID pgtype.UUID) (EnterpriseInquiry, error) {
	row := q.db.QueryRow(ctx, getUserEnterpriseInquiry, userID)
	var i EnterpriseInquiry
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyName,
		&i.ContactName,
		&i.Email,
		&i.Phone,
		&i.CompanySize,
		&i.EstimatedUsage,
		&i.Message,
		&i.Status,
		&i.AdminNotes,
		&i.ProcessedAt,
		&i.ProcessedBy,
		&i.CreatedAt,
	)
	return i, err
}

const hasPendingEnterpriseInquiry = `-- name: HasPendingEnterpriseInquiry :one
SELECT EXISTS(
    SELECT 1 FROM enterprise_inquiries
    WHERE user_id = $1 AND status = 'pending'
) AS has_pending
`

func (q *Queries) HasPendingEnterpriseInquiry(ctx context.Context, userID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, hasPendingEnterpriseInquiry, userID)
	var has_pending bool
	err := row.Scan(&has_pending)
	return has_pending, err
}

const listEnterpriseInquiries = `-- name: ListEnterpriseInquiries :many
SELECT id, user_id, company_name, contact_name, email, phone, company_size, estimated_usage, message, status, admin_notes, processed_at, processed_by, created_at FROM enterprise_inquiries
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListEnterpriseInquiriesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListEnterpriseInquiries(ctx context.Context, arg ListEnterpriseInquiriesParams) ([]EnterpriseInquiry, error) {
	rows, err := q.db.Query(ctx, listEnterpriseInquiries, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EnterpriseInquiry
	for rows.Next() {
		var i EnterpriseInquiry
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CompanyName,
			&i.ContactName,
			&i.Email,
			&i.Phone,
			&i.CompanySize,
			&i.EstimatedUsage,
			&i.Message,
			&i.Status,
			&i.AdminNotes,
			&i.ProcessedAt,
			&i.ProcessedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnterpriseInquiriesByStatus = `-- name: ListEnterpriseInquiriesByStatus :many
SELECT id, user_id, company_name, contact_name, email, phone, company_size, estimated_usage, message, status, admin_notes, processed_at, processed_by, created_at FROM enterprise_inquiries
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListEnterpriseInquiriesByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListEnterpriseInquiriesByStatus(ctx context.Context, arg ListEnterpriseInquiriesByStatusParams) ([]EnterpriseInquiry, error) {
	rows, err := q.db.Query(ctx, listEnterpriseInquiriesByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EnterpriseInquiry
	for rows.Next() {
		var i EnterpriseInquiry
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CompanyName,
			&i.ContactName,
			&i.Email,
			&i.Phone,
			&i.CompanySize,
			&i.EstimatedUsage,
			&i.Message,
			&i.Status,
			&i.AdminNotes,
			&i.ProcessedAt,
			&i.ProcessedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEnterpriseInquiryStatus = `-- name: UpdateEnterpriseInquiryStatus :one
UPDATE enterprise_inquiries
SET
    status = $2,
    admin_notes = $3,
    processed_at = NOW(),
    processed_by = $4
WHERE id = $1
RETURNING id, user_id, company_name, contact_name, email, phone, company_size, estimated_usage, message, status, admin_notes, processed_at, processed_by, created_at
`

type UpdateEnterpriseInquiryStatusParams struct {
	ID          pgtype.UUID `json:"id"`
	Status      string      `json:"status"`
	AdminNotes  *string     `json:"admin_notes"`
	ProcessedBy pgtype.UUID `json:"processed_by"`
}

func (q *Queries) UpdateEnterpriseInquiryStatus(ctx context.Context, arg UpdateEnterpriseInquiryStatusParams) (EnterpriseInquiry, error) {
	row := q.db.QueryRow(ctx, updateEnterpriseInquiryStatus,
		arg.ID,
		arg.Status,
		arg.AdminNotes,
		arg.ProcessedBy,
	)
	var i EnterpriseInquiry
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyName,
		&i.ContactName,
		&i.Email,
		&i.Phone,
		&i.CompanySize,
		&i.EstimatedUsage,
		&i.Message,
		&i.Status,
		&i.AdminNotes,
		&i.ProcessedAt,
		&i.ProcessedBy,
		&i.CreatedAt,
	)
	return i, err
}
