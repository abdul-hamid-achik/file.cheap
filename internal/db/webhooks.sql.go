// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: webhooks.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countDeliveriesByWebhook = `-- name: CountDeliveriesByWebhook :one
SELECT COUNT(*) FROM webhook_deliveries
WHERE webhook_id = $1
`

func (q *Queries) CountDeliveriesByWebhook(ctx context.Context, webhookID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countDeliveriesByWebhook, webhookID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countWebhooksByUser = `-- name: CountWebhooksByUser :one
SELECT COUNT(*) FROM webhooks
WHERE user_id = $1
`

func (q *Queries) CountWebhooksByUser(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countWebhooksByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWebhook = `-- name: CreateWebhook :one
INSERT INTO webhooks (user_id, url, secret, events)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, url, secret, events, active, created_at, updated_at
`

type CreateWebhookParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Url    string      `json:"url"`
	Secret string      `json:"secret"`
	Events []string    `json:"events"`
}

func (q *Queries) CreateWebhook(ctx context.Context, arg CreateWebhookParams) (Webhook, error) {
	row := q.db.QueryRow(ctx, createWebhook,
		arg.UserID,
		arg.Url,
		arg.Secret,
		arg.Events,
	)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.Secret,
		&i.Events,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWebhookDelivery = `-- name: CreateWebhookDelivery :one
INSERT INTO webhook_deliveries (webhook_id, event_type, payload)
VALUES ($1, $2, $3)
RETURNING id, webhook_id, event_type, payload, status, attempts, last_attempt_at, next_retry_at, response_code, response_body, created_at
`

type CreateWebhookDeliveryParams struct {
	WebhookID pgtype.UUID `json:"webhook_id"`
	EventType string      `json:"event_type"`
	Payload   []byte      `json:"payload"`
}

func (q *Queries) CreateWebhookDelivery(ctx context.Context, arg CreateWebhookDeliveryParams) (WebhookDelivery, error) {
	row := q.db.QueryRow(ctx, createWebhookDelivery, arg.WebhookID, arg.EventType, arg.Payload)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.EventType,
		&i.Payload,
		&i.Status,
		&i.Attempts,
		&i.LastAttemptAt,
		&i.NextRetryAt,
		&i.ResponseCode,
		&i.ResponseBody,
		&i.CreatedAt,
	)
	return i, err
}

const deleteWebhook = `-- name: DeleteWebhook :exec
DELETE FROM webhooks
WHERE id = $1 AND user_id = $2
`

type DeleteWebhookParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteWebhook(ctx context.Context, arg DeleteWebhookParams) error {
	_, err := q.db.Exec(ctx, deleteWebhook, arg.ID, arg.UserID)
	return err
}

const getWebhook = `-- name: GetWebhook :one
SELECT id, user_id, url, secret, events, active, created_at, updated_at FROM webhooks
WHERE id = $1 AND user_id = $2
`

type GetWebhookParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetWebhook(ctx context.Context, arg GetWebhookParams) (Webhook, error) {
	row := q.db.QueryRow(ctx, getWebhook, arg.ID, arg.UserID)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.Secret,
		&i.Events,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWebhookByDeliveryID = `-- name: GetWebhookByDeliveryID :one
SELECT w.id, w.user_id, w.url, w.secret, w.events, w.active, w.created_at, w.updated_at FROM webhooks w
JOIN webhook_deliveries wd ON wd.webhook_id = w.id
WHERE wd.id = $1
`

func (q *Queries) GetWebhookByDeliveryID(ctx context.Context, id pgtype.UUID) (Webhook, error) {
	row := q.db.QueryRow(ctx, getWebhookByDeliveryID, id)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.Secret,
		&i.Events,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWebhookByID = `-- name: GetWebhookByID :one
SELECT id, user_id, url, secret, events, active, created_at, updated_at FROM webhooks
WHERE id = $1
`

func (q *Queries) GetWebhookByID(ctx context.Context, id pgtype.UUID) (Webhook, error) {
	row := q.db.QueryRow(ctx, getWebhookByID, id)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.Secret,
		&i.Events,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWebhookDelivery = `-- name: GetWebhookDelivery :one
SELECT id, webhook_id, event_type, payload, status, attempts, last_attempt_at, next_retry_at, response_code, response_body, created_at FROM webhook_deliveries
WHERE id = $1
`

func (q *Queries) GetWebhookDelivery(ctx context.Context, id pgtype.UUID) (WebhookDelivery, error) {
	row := q.db.QueryRow(ctx, getWebhookDelivery, id)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.EventType,
		&i.Payload,
		&i.Status,
		&i.Attempts,
		&i.LastAttemptAt,
		&i.NextRetryAt,
		&i.ResponseCode,
		&i.ResponseBody,
		&i.CreatedAt,
	)
	return i, err
}

const listActiveWebhooksByUserAndEvent = `-- name: ListActiveWebhooksByUserAndEvent :many
SELECT id, user_id, url, secret, events, active, created_at, updated_at FROM webhooks
WHERE user_id = $1 AND active = true AND $2::text = ANY(events)
`

type ListActiveWebhooksByUserAndEventParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	EventType string      `json:"event_type"`
}

func (q *Queries) ListActiveWebhooksByUserAndEvent(ctx context.Context, arg ListActiveWebhooksByUserAndEventParams) ([]Webhook, error) {
	rows, err := q.db.Query(ctx, listActiveWebhooksByUserAndEvent, arg.UserID, arg.EventType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Webhook
	for rows.Next() {
		var i Webhook
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Url,
			&i.Secret,
			&i.Events,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeliveriesByWebhook = `-- name: ListDeliveriesByWebhook :many
SELECT id, webhook_id, event_type, payload, status, attempts, last_attempt_at, next_retry_at, response_code, response_body, created_at FROM webhook_deliveries
WHERE webhook_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListDeliveriesByWebhookParams struct {
	WebhookID pgtype.UUID `json:"webhook_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) ListDeliveriesByWebhook(ctx context.Context, arg ListDeliveriesByWebhookParams) ([]WebhookDelivery, error) {
	rows, err := q.db.Query(ctx, listDeliveriesByWebhook, arg.WebhookID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WebhookDelivery
	for rows.Next() {
		var i WebhookDelivery
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.EventType,
			&i.Payload,
			&i.Status,
			&i.Attempts,
			&i.LastAttemptAt,
			&i.NextRetryAt,
			&i.ResponseCode,
			&i.ResponseBody,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingDeliveries = `-- name: ListPendingDeliveries :many
SELECT id, webhook_id, event_type, payload, status, attempts, last_attempt_at, next_retry_at, response_code, response_body, created_at FROM webhook_deliveries
WHERE status IN ('pending', 'retrying')
  AND (next_retry_at IS NULL OR next_retry_at <= NOW())
ORDER BY created_at ASC
LIMIT $1
`

func (q *Queries) ListPendingDeliveries(ctx context.Context, limit int32) ([]WebhookDelivery, error) {
	rows, err := q.db.Query(ctx, listPendingDeliveries, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WebhookDelivery
	for rows.Next() {
		var i WebhookDelivery
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.EventType,
			&i.Payload,
			&i.Status,
			&i.Attempts,
			&i.LastAttemptAt,
			&i.NextRetryAt,
			&i.ResponseCode,
			&i.ResponseBody,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhooksByUser = `-- name: ListWebhooksByUser :many
SELECT id, user_id, url, secret, events, active, created_at, updated_at FROM webhooks
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListWebhooksByUserParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListWebhooksByUser(ctx context.Context, arg ListWebhooksByUserParams) ([]Webhook, error) {
	rows, err := q.db.Query(ctx, listWebhooksByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Webhook
	for rows.Next() {
		var i Webhook
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Url,
			&i.Secret,
			&i.Events,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markDeliveryFailed = `-- name: MarkDeliveryFailed :exec
UPDATE webhook_deliveries
SET status = 'failed', attempts = attempts + 1, last_attempt_at = NOW(),
    response_code = $2, response_body = $3
WHERE id = $1
`

type MarkDeliveryFailedParams struct {
	ID           pgtype.UUID `json:"id"`
	ResponseCode *int32      `json:"response_code"`
	ResponseBody *string     `json:"response_body"`
}

func (q *Queries) MarkDeliveryFailed(ctx context.Context, arg MarkDeliveryFailedParams) error {
	_, err := q.db.Exec(ctx, markDeliveryFailed, arg.ID, arg.ResponseCode, arg.ResponseBody)
	return err
}

const markDeliverySuccess = `-- name: MarkDeliverySuccess :exec
UPDATE webhook_deliveries
SET status = 'success', attempts = attempts + 1, last_attempt_at = NOW(),
    response_code = $2, response_body = $3
WHERE id = $1
`

type MarkDeliverySuccessParams struct {
	ID           pgtype.UUID `json:"id"`
	ResponseCode *int32      `json:"response_code"`
	ResponseBody *string     `json:"response_body"`
}

func (q *Queries) MarkDeliverySuccess(ctx context.Context, arg MarkDeliverySuccessParams) error {
	_, err := q.db.Exec(ctx, markDeliverySuccess, arg.ID, arg.ResponseCode, arg.ResponseBody)
	return err
}

const updateDeliveryRetry = `-- name: UpdateDeliveryRetry :exec
UPDATE webhook_deliveries
SET status = 'retrying', attempts = attempts + 1, last_attempt_at = NOW(),
    next_retry_at = $2, response_code = $3, response_body = $4
WHERE id = $1
`

type UpdateDeliveryRetryParams struct {
	ID           pgtype.UUID        `json:"id"`
	NextRetryAt  pgtype.Timestamptz `json:"next_retry_at"`
	ResponseCode *int32             `json:"response_code"`
	ResponseBody *string            `json:"response_body"`
}

func (q *Queries) UpdateDeliveryRetry(ctx context.Context, arg UpdateDeliveryRetryParams) error {
	_, err := q.db.Exec(ctx, updateDeliveryRetry,
		arg.ID,
		arg.NextRetryAt,
		arg.ResponseCode,
		arg.ResponseBody,
	)
	return err
}

const updateWebhook = `-- name: UpdateWebhook :one
UPDATE webhooks
SET url = $3, events = $4, active = $5, updated_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, url, secret, events, active, created_at, updated_at
`

type UpdateWebhookParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
	Url    string      `json:"url"`
	Events []string    `json:"events"`
	Active bool        `json:"active"`
}

func (q *Queries) UpdateWebhook(ctx context.Context, arg UpdateWebhookParams) (Webhook, error) {
	row := q.db.QueryRow(ctx, updateWebhook,
		arg.ID,
		arg.UserID,
		arg.Url,
		arg.Events,
		arg.Active,
	)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.Secret,
		&i.Events,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
