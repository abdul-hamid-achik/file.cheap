// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tags.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BulkCreateFileTagsParams struct {
	FileID  pgtype.UUID `json:"file_id"`
	UserID  pgtype.UUID `json:"user_id"`
	TagName string      `json:"tag_name"`
}

const countFilesByTag = `-- name: CountFilesByTag :one
SELECT COUNT(DISTINCT file_id)
FROM file_tags
WHERE user_id = $1 AND tag_name = $2
`

type CountFilesByTagParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	TagName string      `json:"tag_name"`
}

func (q *Queries) CountFilesByTag(ctx context.Context, arg CountFilesByTagParams) (int64, error) {
	row := q.db.QueryRow(ctx, countFilesByTag, arg.UserID, arg.TagName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFileTag = `-- name: CreateFileTag :one
INSERT INTO file_tags (file_id, user_id, tag_name)
VALUES ($1, $2, $3)
ON CONFLICT (file_id, tag_name) DO NOTHING
RETURNING id, file_id, user_id, tag_name, created_at
`

type CreateFileTagParams struct {
	FileID  pgtype.UUID `json:"file_id"`
	UserID  pgtype.UUID `json:"user_id"`
	TagName string      `json:"tag_name"`
}

func (q *Queries) CreateFileTag(ctx context.Context, arg CreateFileTagParams) (FileTag, error) {
	row := q.db.QueryRow(ctx, createFileTag, arg.FileID, arg.UserID, arg.TagName)
	var i FileTag
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.UserID,
		&i.TagName,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAllTagsFromFile = `-- name: DeleteAllTagsFromFile :exec
DELETE FROM file_tags
WHERE file_id = $1 AND user_id = $2
`

type DeleteAllTagsFromFileParams struct {
	FileID pgtype.UUID `json:"file_id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteAllTagsFromFile(ctx context.Context, arg DeleteAllTagsFromFileParams) error {
	_, err := q.db.Exec(ctx, deleteAllTagsFromFile, arg.FileID, arg.UserID)
	return err
}

const deleteFileTag = `-- name: DeleteFileTag :exec
DELETE FROM file_tags
WHERE file_id = $1 AND tag_name = $2 AND user_id = $3
`

type DeleteFileTagParams struct {
	FileID  pgtype.UUID `json:"file_id"`
	TagName string      `json:"tag_name"`
	UserID  pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteFileTag(ctx context.Context, arg DeleteFileTagParams) error {
	_, err := q.db.Exec(ctx, deleteFileTag, arg.FileID, arg.TagName, arg.UserID)
	return err
}

const deleteTagByName = `-- name: DeleteTagByName :exec
DELETE FROM file_tags
WHERE user_id = $1 AND tag_name = $2
`

type DeleteTagByNameParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	TagName string      `json:"tag_name"`
}

func (q *Queries) DeleteTagByName(ctx context.Context, arg DeleteTagByNameParams) error {
	_, err := q.db.Exec(ctx, deleteTagByName, arg.UserID, arg.TagName)
	return err
}

const listFilesByTag = `-- name: ListFilesByTag :many
SELECT f.id, f.user_id, f.folder_id, f.filename, f.content_type, f.size_bytes, f.storage_key, f.status, f.created_at, f.updated_at, f.deleted_at, COUNT(*) OVER() AS total_count
FROM files f
JOIN file_tags ft ON ft.file_id = f.id
WHERE ft.user_id = $1
  AND ft.tag_name = $2
  AND f.deleted_at IS NULL
ORDER BY f.created_at DESC
LIMIT $3 OFFSET $4
`

type ListFilesByTagParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	TagName string      `json:"tag_name"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type ListFilesByTagRow struct {
	ID          pgtype.UUID        `json:"id"`
	UserID      pgtype.UUID        `json:"user_id"`
	FolderID    pgtype.UUID        `json:"folder_id"`
	Filename    string             `json:"filename"`
	ContentType string             `json:"content_type"`
	SizeBytes   int64              `json:"size_bytes"`
	StorageKey  string             `json:"storage_key"`
	Status      FileStatus         `json:"status"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
	TotalCount  int64              `json:"total_count"`
}

func (q *Queries) ListFilesByTag(ctx context.Context, arg ListFilesByTagParams) ([]ListFilesByTagRow, error) {
	rows, err := q.db.Query(ctx, listFilesByTag,
		arg.UserID,
		arg.TagName,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFilesByTagRow
	for rows.Next() {
		var i ListFilesByTagRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FolderID,
			&i.Filename,
			&i.ContentType,
			&i.SizeBytes,
			&i.StorageKey,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsByFile = `-- name: ListTagsByFile :many
SELECT id, file_id, user_id, tag_name, created_at FROM file_tags
WHERE file_id = $1
ORDER BY tag_name
`

func (q *Queries) ListTagsByFile(ctx context.Context, fileID pgtype.UUID) ([]FileTag, error) {
	rows, err := q.db.Query(ctx, listTagsByFile, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FileTag
	for rows.Next() {
		var i FileTag
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.UserID,
			&i.TagName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsByUser = `-- name: ListTagsByUser :many
SELECT DISTINCT tag_name, COUNT(*) as file_count
FROM file_tags
WHERE user_id = $1
GROUP BY tag_name
ORDER BY tag_name
`

type ListTagsByUserRow struct {
	TagName   string `json:"tag_name"`
	FileCount int64  `json:"file_count"`
}

func (q *Queries) ListTagsByUser(ctx context.Context, userID pgtype.UUID) ([]ListTagsByUserRow, error) {
	rows, err := q.db.Query(ctx, listTagsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTagsByUserRow
	for rows.Next() {
		var i ListTagsByUserRow
		if err := rows.Scan(&i.TagName, &i.FileCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const renameTag = `-- name: RenameTag :exec
UPDATE file_tags
SET tag_name = $3
WHERE user_id = $1 AND tag_name = $2
`

type RenameTagParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	TagName   string      `json:"tag_name"`
	TagName_2 string      `json:"tag_name_2"`
}

func (q *Queries) RenameTag(ctx context.Context, arg RenameTagParams) error {
	_, err := q.db.Exec(ctx, renameTag, arg.UserID, arg.TagName, arg.TagName_2)
	return err
}
