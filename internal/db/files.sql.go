// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: files.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countFilesByUser = `-- name: CountFilesByUser :one
SELECT COUNT(*) FROM files 
WHERE user_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountFilesByUser(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countFilesByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFile = `-- name: CreateFile :one
INSERT INTO files (
    user_id,
    filename,
    content_type,
    size_bytes,
    storage_key,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, user_id, folder_id, filename, content_type, size_bytes, storage_key, status, created_at, updated_at, deleted_at
`

type CreateFileParams struct {
	UserID      pgtype.UUID `json:"user_id"`
	Filename    string      `json:"filename"`
	ContentType string      `json:"content_type"`
	SizeBytes   int64       `json:"size_bytes"`
	StorageKey  string      `json:"storage_key"`
	Status      FileStatus  `json:"status"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, createFile,
		arg.UserID,
		arg.Filename,
		arg.ContentType,
		arg.SizeBytes,
		arg.StorageKey,
		arg.Status,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FolderID,
		&i.Filename,
		&i.ContentType,
		&i.SizeBytes,
		&i.StorageKey,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getFile = `-- name: GetFile :one
SELECT id, user_id, folder_id, filename, content_type, size_bytes, storage_key, status, created_at, updated_at, deleted_at FROM files 
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetFile(ctx context.Context, id pgtype.UUID) (File, error) {
	row := q.db.QueryRow(ctx, getFile, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FolderID,
		&i.Filename,
		&i.ContentType,
		&i.SizeBytes,
		&i.StorageKey,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getFilesByIDs = `-- name: GetFilesByIDs :many
SELECT id, user_id, folder_id, filename, content_type, size_bytes, storage_key, status, created_at, updated_at, deleted_at FROM files
WHERE id = ANY($1::uuid[]) AND deleted_at IS NULL
`

func (q *Queries) GetFilesByIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]File, error) {
	rows, err := q.db.Query(ctx, getFilesByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FolderID,
			&i.Filename,
			&i.ContentType,
			&i.SizeBytes,
			&i.StorageKey,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStorageUsage = `-- name: GetUserStorageUsage :one
SELECT COALESCE(SUM(size_bytes), 0)::bigint as total_bytes
FROM files
WHERE user_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetUserStorageUsage(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getUserStorageUsage, userID)
	var total_bytes int64
	err := row.Scan(&total_bytes)
	return total_bytes, err
}

const getUserVideoStorageUsage = `-- name: GetUserVideoStorageUsage :one
SELECT COALESCE(SUM(size_bytes), 0)::bigint as total_bytes
FROM files
WHERE user_id = $1
  AND deleted_at IS NULL
  AND content_type LIKE 'video/%'
`

func (q *Queries) GetUserVideoStorageUsage(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getUserVideoStorageUsage, userID)
	var total_bytes int64
	err := row.Scan(&total_bytes)
	return total_bytes, err
}

const hardDeleteFile = `-- name: HardDeleteFile :exec
DELETE FROM files WHERE id = $1
`

func (q *Queries) HardDeleteFile(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteFile, id)
	return err
}

const listExpiredSoftDeletedFiles = `-- name: ListExpiredSoftDeletedFiles :many
SELECT id, storage_key, user_id
FROM files
WHERE deleted_at IS NOT NULL
  AND deleted_at < NOW() - INTERVAL '7 days'
LIMIT $1
`

type ListExpiredSoftDeletedFilesRow struct {
	ID         pgtype.UUID `json:"id"`
	StorageKey string      `json:"storage_key"`
	UserID     pgtype.UUID `json:"user_id"`
}

func (q *Queries) ListExpiredSoftDeletedFiles(ctx context.Context, limit int32) ([]ListExpiredSoftDeletedFilesRow, error) {
	rows, err := q.db.Query(ctx, listExpiredSoftDeletedFiles, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListExpiredSoftDeletedFilesRow
	for rows.Next() {
		var i ListExpiredSoftDeletedFilesRow
		if err := rows.Scan(&i.ID, &i.StorageKey, &i.UserID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesByUser = `-- name: ListFilesByUser :many
SELECT id, user_id, folder_id, filename, content_type, size_bytes, storage_key, status, created_at, updated_at, deleted_at FROM files 
WHERE user_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListFilesByUserParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListFilesByUser(ctx context.Context, arg ListFilesByUserParams) ([]File, error) {
	rows, err := q.db.Query(ctx, listFilesByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FolderID,
			&i.Filename,
			&i.ContentType,
			&i.SizeBytes,
			&i.StorageKey,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesByUserWithCount = `-- name: ListFilesByUserWithCount :many
SELECT id, user_id, folder_id, filename, content_type, size_bytes, storage_key, status, created_at, updated_at, deleted_at, COUNT(*) OVER() AS total_count FROM files
WHERE user_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListFilesByUserWithCountParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type ListFilesByUserWithCountRow struct {
	ID          pgtype.UUID        `json:"id"`
	UserID      pgtype.UUID        `json:"user_id"`
	FolderID    pgtype.UUID        `json:"folder_id"`
	Filename    string             `json:"filename"`
	ContentType string             `json:"content_type"`
	SizeBytes   int64              `json:"size_bytes"`
	StorageKey  string             `json:"storage_key"`
	Status      FileStatus         `json:"status"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
	TotalCount  int64              `json:"total_count"`
}

func (q *Queries) ListFilesByUserWithCount(ctx context.Context, arg ListFilesByUserWithCountParams) ([]ListFilesByUserWithCountRow, error) {
	rows, err := q.db.Query(ctx, listFilesByUserWithCount, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFilesByUserWithCountRow
	for rows.Next() {
		var i ListFilesByUserWithCountRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FolderID,
			&i.Filename,
			&i.ContentType,
			&i.SizeBytes,
			&i.StorageKey,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRetentionExpiredFiles = `-- name: ListRetentionExpiredFiles :many
SELECT f.id, f.storage_key, f.user_id
FROM files f
JOIN user_settings us ON us.user_id = f.user_id
WHERE f.deleted_at IS NULL
  AND f.created_at < NOW() - (us.default_retention_days || ' days')::INTERVAL
LIMIT $1
`

type ListRetentionExpiredFilesRow struct {
	ID         pgtype.UUID `json:"id"`
	StorageKey string      `json:"storage_key"`
	UserID     pgtype.UUID `json:"user_id"`
}

func (q *Queries) ListRetentionExpiredFiles(ctx context.Context, limit int32) ([]ListRetentionExpiredFilesRow, error) {
	rows, err := q.db.Query(ctx, listRetentionExpiredFiles, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRetentionExpiredFilesRow
	for rows.Next() {
		var i ListRetentionExpiredFilesRow
		if err := rows.Scan(&i.ID, &i.StorageKey, &i.UserID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markOriginalDeleted = `-- name: MarkOriginalDeleted :exec
UPDATE files
SET storage_key = '', updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) MarkOriginalDeleted(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markOriginalDeleted, id)
	return err
}

const searchFilesByUser = `-- name: SearchFilesByUser :many
SELECT id, user_id, folder_id, filename, content_type, size_bytes, storage_key, status, created_at, updated_at, deleted_at, COUNT(*) OVER() AS total_count FROM files
WHERE user_id = $1
  AND deleted_at IS NULL
  AND ($2::text = '' OR filename ILIKE '%' || $2 || '%')
  AND ($3::text = '' OR content_type LIKE $3 || '%')
  AND ($4::timestamptz IS NULL OR created_at >= $4)
  AND ($5::timestamptz IS NULL OR created_at <= $5)
  AND ($6::text = '' OR status = $6::file_status)
ORDER BY created_at DESC
LIMIT $7 OFFSET $8
`

type SearchFilesByUserParams struct {
	UserID  pgtype.UUID        `json:"user_id"`
	Column2 string             `json:"column_2"`
	Column3 string             `json:"column_3"`
	Column4 pgtype.Timestamptz `json:"column_4"`
	Column5 pgtype.Timestamptz `json:"column_5"`
	Column6 string             `json:"column_6"`
	Limit   int32              `json:"limit"`
	Offset  int32              `json:"offset"`
}

type SearchFilesByUserRow struct {
	ID          pgtype.UUID        `json:"id"`
	UserID      pgtype.UUID        `json:"user_id"`
	FolderID    pgtype.UUID        `json:"folder_id"`
	Filename    string             `json:"filename"`
	ContentType string             `json:"content_type"`
	SizeBytes   int64              `json:"size_bytes"`
	StorageKey  string             `json:"storage_key"`
	Status      FileStatus         `json:"status"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
	TotalCount  int64              `json:"total_count"`
}

func (q *Queries) SearchFilesByUser(ctx context.Context, arg SearchFilesByUserParams) ([]SearchFilesByUserRow, error) {
	rows, err := q.db.Query(ctx, searchFilesByUser,
		arg.UserID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchFilesByUserRow
	for rows.Next() {
		var i SearchFilesByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FolderID,
			&i.Filename,
			&i.ContentType,
			&i.SizeBytes,
			&i.StorageKey,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteFile = `-- name: SoftDeleteFile :exec
UPDATE files
SET deleted_at = NOW(), updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteFile(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteFile, id)
	return err
}

const updateFileStatus = `-- name: UpdateFileStatus :exec
UPDATE files 
SET status = $2, updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateFileStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status FileStatus  `json:"status"`
}

func (q *Queries) UpdateFileStatus(ctx context.Context, arg UpdateFileStatusParams) error {
	_, err := q.db.Exec(ctx, updateFileStatus, arg.ID, arg.Status)
	return err
}
