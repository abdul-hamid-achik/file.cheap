// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"database/sql/driver"
	"fmt"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

type AuditAction string

const (
	AuditActionFileupload         AuditAction = "file.upload"
	AuditActionFiledownload       AuditAction = "file.download"
	AuditActionFiledelete         AuditAction = "file.delete"
	AuditActionFileshare          AuditAction = "file.share"
	AuditActionShareaccess        AuditAction = "share.access"
	AuditActionSharedelete        AuditAction = "share.delete"
	AuditActionUserlogin          AuditAction = "user.login"
	AuditActionUserlogout         AuditAction = "user.logout"
	AuditActionUserpasswordChange AuditAction = "user.password_change"
	AuditActionSettingsupdate     AuditAction = "settings.update"
	AuditActionApiTokencreate     AuditAction = "api_token.create"
	AuditActionApiTokendelete     AuditAction = "api_token.delete"
	AuditActionWebhookcreate      AuditAction = "webhook.create"
	AuditActionWebhookdelete      AuditAction = "webhook.delete"
)

func (e *AuditAction) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuditAction(s)
	case string:
		*e = AuditAction(s)
	default:
		return fmt.Errorf("unsupported scan type for AuditAction: %T", src)
	}
	return nil
}

type NullAuditAction struct {
	AuditAction AuditAction `json:"audit_action"`
	Valid       bool        `json:"valid"` // Valid is true if AuditAction is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuditAction) Scan(value interface{}) error {
	if value == nil {
		ns.AuditAction, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuditAction.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuditAction) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuditAction), nil
}

type BatchStatus string

const (
	BatchStatusPending    BatchStatus = "pending"
	BatchStatusProcessing BatchStatus = "processing"
	BatchStatusCompleted  BatchStatus = "completed"
	BatchStatusFailed     BatchStatus = "failed"
	BatchStatusPartial    BatchStatus = "partial"
)

func (e *BatchStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BatchStatus(s)
	case string:
		*e = BatchStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for BatchStatus: %T", src)
	}
	return nil
}

type NullBatchStatus struct {
	BatchStatus BatchStatus `json:"batch_status"`
	Valid       bool        `json:"valid"` // Valid is true if BatchStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBatchStatus) Scan(value interface{}) error {
	if value == nil {
		ns.BatchStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BatchStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBatchStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BatchStatus), nil
}

type FileStatus string

const (
	FileStatusPending    FileStatus = "pending"
	FileStatusProcessing FileStatus = "processing"
	FileStatusCompleted  FileStatus = "completed"
	FileStatusFailed     FileStatus = "failed"
)

func (e *FileStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = FileStatus(s)
	case string:
		*e = FileStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for FileStatus: %T", src)
	}
	return nil
}

type NullFileStatus struct {
	FileStatus FileStatus `json:"file_status"`
	Valid      bool       `json:"valid"` // Valid is true if FileStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullFileStatus) Scan(value interface{}) error {
	if value == nil {
		ns.FileStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.FileStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullFileStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.FileStatus), nil
}

type JobStatus string

const (
	JobStatusPending   JobStatus = "pending"
	JobStatusRunning   JobStatus = "running"
	JobStatusCompleted JobStatus = "completed"
	JobStatusFailed    JobStatus = "failed"
)

func (e *JobStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = JobStatus(s)
	case string:
		*e = JobStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for JobStatus: %T", src)
	}
	return nil
}

type NullJobStatus struct {
	JobStatus JobStatus `json:"job_status"`
	Valid     bool      `json:"valid"` // Valid is true if JobStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullJobStatus) Scan(value interface{}) error {
	if value == nil {
		ns.JobStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.JobStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullJobStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.JobStatus), nil
}

type JobType string

const (
	JobTypeThumbnail      JobType = "thumbnail"
	JobTypeResize         JobType = "resize"
	JobTypeWebp           JobType = "webp"
	JobTypeWatermark      JobType = "watermark"
	JobTypePdfThumbnail   JobType = "pdf_thumbnail"
	JobTypeMetadata       JobType = "metadata"
	JobTypeOptimize       JobType = "optimize"
	JobTypeVideoThumbnail JobType = "video_thumbnail"
	JobTypeVideoTranscode JobType = "video_transcode"
	JobTypeVideoHls       JobType = "video_hls"
	JobTypeVideoWatermark JobType = "video_watermark"
)

func (e *JobType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = JobType(s)
	case string:
		*e = JobType(s)
	default:
		return fmt.Errorf("unsupported scan type for JobType: %T", src)
	}
	return nil
}

type NullJobType struct {
	JobType JobType `json:"job_type"`
	Valid   bool    `json:"valid"` // Valid is true if JobType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullJobType) Scan(value interface{}) error {
	if value == nil {
		ns.JobType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.JobType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullJobType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.JobType), nil
}

type OauthProvider string

const (
	OauthProviderGoogle OauthProvider = "google"
	OauthProviderGithub OauthProvider = "github"
)

func (e *OauthProvider) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OauthProvider(s)
	case string:
		*e = OauthProvider(s)
	default:
		return fmt.Errorf("unsupported scan type for OauthProvider: %T", src)
	}
	return nil
}

type NullOauthProvider struct {
	OauthProvider OauthProvider `json:"oauth_provider"`
	Valid         bool          `json:"valid"` // Valid is true if OauthProvider is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOauthProvider) Scan(value interface{}) error {
	if value == nil {
		ns.OauthProvider, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OauthProvider.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOauthProvider) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OauthProvider), nil
}

type SubscriptionStatus string

const (
	SubscriptionStatusNone     SubscriptionStatus = "none"
	SubscriptionStatusTrialing SubscriptionStatus = "trialing"
	SubscriptionStatusActive   SubscriptionStatus = "active"
	SubscriptionStatusPastDue  SubscriptionStatus = "past_due"
	SubscriptionStatusCanceled SubscriptionStatus = "canceled"
	SubscriptionStatusUnpaid   SubscriptionStatus = "unpaid"
)

func (e *SubscriptionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SubscriptionStatus(s)
	case string:
		*e = SubscriptionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SubscriptionStatus: %T", src)
	}
	return nil
}

type NullSubscriptionStatus struct {
	SubscriptionStatus SubscriptionStatus `json:"subscription_status"`
	Valid              bool               `json:"valid"` // Valid is true if SubscriptionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSubscriptionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SubscriptionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SubscriptionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSubscriptionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SubscriptionStatus), nil
}

type SubscriptionTier string

const (
	SubscriptionTierFree       SubscriptionTier = "free"
	SubscriptionTierPro        SubscriptionTier = "pro"
	SubscriptionTierEnterprise SubscriptionTier = "enterprise"
)

func (e *SubscriptionTier) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SubscriptionTier(s)
	case string:
		*e = SubscriptionTier(s)
	default:
		return fmt.Errorf("unsupported scan type for SubscriptionTier: %T", src)
	}
	return nil
}

type NullSubscriptionTier struct {
	SubscriptionTier SubscriptionTier `json:"subscription_tier"`
	Valid            bool             `json:"valid"` // Valid is true if SubscriptionTier is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSubscriptionTier) Scan(value interface{}) error {
	if value == nil {
		ns.SubscriptionTier, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SubscriptionTier.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSubscriptionTier) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SubscriptionTier), nil
}

type UserRole string

const (
	UserRoleUser  UserRole = "user"
	UserRoleAdmin UserRole = "admin"
)

func (e *UserRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserRole(s)
	case string:
		*e = UserRole(s)
	default:
		return fmt.Errorf("unsupported scan type for UserRole: %T", src)
	}
	return nil
}

type NullUserRole struct {
	UserRole UserRole `json:"user_role"`
	Valid    bool     `json:"valid"` // Valid is true if UserRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserRole) Scan(value interface{}) error {
	if value == nil {
		ns.UserRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserRole), nil
}

type VariantType string

const (
	VariantTypeThumbnail         VariantType = "thumbnail"
	VariantTypeSm                VariantType = "sm"
	VariantTypeMd                VariantType = "md"
	VariantTypeLg                VariantType = "lg"
	VariantTypeXl                VariantType = "xl"
	VariantTypeOg                VariantType = "og"
	VariantTypeTwitter           VariantType = "twitter"
	VariantTypeInstagramSquare   VariantType = "instagram_square"
	VariantTypeInstagramPortrait VariantType = "instagram_portrait"
	VariantTypeInstagramStory    VariantType = "instagram_story"
	VariantTypeWebp              VariantType = "webp"
	VariantTypeWatermarked       VariantType = "watermarked"
	VariantTypeOptimized         VariantType = "optimized"
	VariantTypePdfPreview        VariantType = "pdf_preview"
)

func (e *VariantType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = VariantType(s)
	case string:
		*e = VariantType(s)
	default:
		return fmt.Errorf("unsupported scan type for VariantType: %T", src)
	}
	return nil
}

type NullVariantType struct {
	VariantType VariantType `json:"variant_type"`
	Valid       bool        `json:"valid"` // Valid is true if VariantType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullVariantType) Scan(value interface{}) error {
	if value == nil {
		ns.VariantType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.VariantType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullVariantType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.VariantType), nil
}

type WebhookDeliveryStatus string

const (
	WebhookDeliveryStatusPending  WebhookDeliveryStatus = "pending"
	WebhookDeliveryStatusSuccess  WebhookDeliveryStatus = "success"
	WebhookDeliveryStatusFailed   WebhookDeliveryStatus = "failed"
	WebhookDeliveryStatusRetrying WebhookDeliveryStatus = "retrying"
)

func (e *WebhookDeliveryStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WebhookDeliveryStatus(s)
	case string:
		*e = WebhookDeliveryStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for WebhookDeliveryStatus: %T", src)
	}
	return nil
}

type NullWebhookDeliveryStatus struct {
	WebhookDeliveryStatus WebhookDeliveryStatus `json:"webhook_delivery_status"`
	Valid                 bool                  `json:"valid"` // Valid is true if WebhookDeliveryStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWebhookDeliveryStatus) Scan(value interface{}) error {
	if value == nil {
		ns.WebhookDeliveryStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WebhookDeliveryStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWebhookDeliveryStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WebhookDeliveryStatus), nil
}

type AdminAlertConfig struct {
	ID             pgtype.UUID        `json:"id"`
	MetricName     string             `json:"metric_name"`
	ThresholdValue float64            `json:"threshold_value"`
	Enabled        *bool              `json:"enabled"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
}

type ApiToken struct {
	ID          pgtype.UUID        `json:"id"`
	UserID      pgtype.UUID        `json:"user_id"`
	Name        string             `json:"name"`
	TokenHash   string             `json:"token_hash"`
	TokenPrefix string             `json:"token_prefix"`
	Permissions []string           `json:"permissions"`
	LastUsedAt  pgtype.Timestamptz `json:"last_used_at"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

type AuditLog struct {
	ID           pgtype.UUID        `json:"id"`
	UserID       pgtype.UUID        `json:"user_id"`
	Action       AuditAction        `json:"action"`
	ResourceType string             `json:"resource_type"`
	ResourceID   pgtype.UUID        `json:"resource_id"`
	IpAddress    *netip.Addr        `json:"ip_address"`
	UserAgent    *string            `json:"user_agent"`
	Metadata     []byte             `json:"metadata"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

type BatchItem struct {
	ID           pgtype.UUID        `json:"id"`
	BatchID      pgtype.UUID        `json:"batch_id"`
	FileID       pgtype.UUID        `json:"file_id"`
	Status       BatchStatus        `json:"status"`
	JobIds       []string           `json:"job_ids"`
	ErrorMessage *string            `json:"error_message"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
}

type BatchOperation struct {
	ID             pgtype.UUID        `json:"id"`
	UserID         pgtype.UUID        `json:"user_id"`
	Status         BatchStatus        `json:"status"`
	TotalFiles     int32              `json:"total_files"`
	CompletedFiles int32              `json:"completed_files"`
	FailedFiles    int32              `json:"failed_files"`
	Presets        []string           `json:"presets"`
	Webp           bool               `json:"webp"`
	Quality        int32              `json:"quality"`
	Watermark      *string            `json:"watermark"`
	ErrorMessage   *string            `json:"error_message"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	StartedAt      pgtype.Timestamptz `json:"started_at"`
	CompletedAt    pgtype.Timestamptz `json:"completed_at"`
}

type EmailVerification struct {
	ID         pgtype.UUID        `json:"id"`
	UserID     pgtype.UUID        `json:"user_id"`
	TokenHash  string             `json:"token_hash"`
	ExpiresAt  pgtype.Timestamptz `json:"expires_at"`
	VerifiedAt pgtype.Timestamptz `json:"verified_at"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

type EnterpriseInquiry struct {
	ID             pgtype.UUID        `json:"id"`
	UserID         pgtype.UUID        `json:"user_id"`
	CompanyName    string             `json:"company_name"`
	ContactName    string             `json:"contact_name"`
	Email          string             `json:"email"`
	Phone          *string            `json:"phone"`
	CompanySize    string             `json:"company_size"`
	EstimatedUsage string             `json:"estimated_usage"`
	Message        string             `json:"message"`
	Status         string             `json:"status"`
	AdminNotes     *string            `json:"admin_notes"`
	ProcessedAt    pgtype.Timestamptz `json:"processed_at"`
	ProcessedBy    pgtype.UUID        `json:"processed_by"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
}

type File struct {
	ID          pgtype.UUID        `json:"id"`
	UserID      pgtype.UUID        `json:"user_id"`
	FolderID    pgtype.UUID        `json:"folder_id"`
	Filename    string             `json:"filename"`
	ContentType string             `json:"content_type"`
	SizeBytes   int64              `json:"size_bytes"`
	StorageKey  string             `json:"storage_key"`
	Status      FileStatus         `json:"status"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
}

type FileShare struct {
	ID                pgtype.UUID        `json:"id"`
	FileID            pgtype.UUID        `json:"file_id"`
	Token             string             `json:"token"`
	ExpiresAt         pgtype.Timestamptz `json:"expires_at"`
	AllowedTransforms []string           `json:"allowed_transforms"`
	AccessCount       int32              `json:"access_count"`
	PasswordHash      *string            `json:"password_hash"`
	MaxDownloads      *int32             `json:"max_downloads"`
	DownloadCount     int32              `json:"download_count"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
}

type FileVariant struct {
	ID          pgtype.UUID        `json:"id"`
	FileID      pgtype.UUID        `json:"file_id"`
	VariantType VariantType        `json:"variant_type"`
	ContentType string             `json:"content_type"`
	SizeBytes   int64              `json:"size_bytes"`
	StorageKey  string             `json:"storage_key"`
	Width       *int32             `json:"width"`
	Height      *int32             `json:"height"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

type Folder struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	ParentID  pgtype.UUID        `json:"parent_id"`
	Name      string             `json:"name"`
	Path      string             `json:"path"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

type MonthlyUsage struct {
	ID                    pgtype.UUID        `json:"id"`
	UserID                pgtype.UUID        `json:"user_id"`
	YearMonth             string             `json:"year_month"`
	TransformationsCount  int32              `json:"transformations_count"`
	BytesProcessed        int64              `json:"bytes_processed"`
	FilesUploaded         int32              `json:"files_uploaded"`
	VideoSecondsProcessed int32              `json:"video_seconds_processed"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
}

type Notification struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	Type      string             `json:"type"`
	Title     string             `json:"title"`
	Message   string             `json:"message"`
	Link      *string            `json:"link"`
	ReadAt    pgtype.Timestamptz `json:"read_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type OauthAccount struct {
	ID             pgtype.UUID        `json:"id"`
	UserID         pgtype.UUID        `json:"user_id"`
	Provider       OauthProvider      `json:"provider"`
	ProviderUserID string             `json:"provider_user_id"`
	AccessToken    *string            `json:"access_token"`
	RefreshToken   *string            `json:"refresh_token"`
	ExpiresAt      pgtype.Timestamptz `json:"expires_at"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
}

type PasswordReset struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	TokenHash string             `json:"token_hash"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	UsedAt    pgtype.Timestamptz `json:"used_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type ProcessingJob struct {
	ID           pgtype.UUID        `json:"id"`
	FileID       pgtype.UUID        `json:"file_id"`
	JobType      JobType            `json:"job_type"`
	Status       JobStatus          `json:"status"`
	Priority     int32              `json:"priority"`
	Attempts     int32              `json:"attempts"`
	ErrorMessage *string            `json:"error_message"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	StartedAt    pgtype.Timestamptz `json:"started_at"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
}

type Session struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	TokenHash string             `json:"token_hash"`
	UserAgent *string            `json:"user_agent"`
	IpAddress *netip.Addr        `json:"ip_address"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type TransformCache struct {
	ID              pgtype.UUID        `json:"id"`
	FileID          pgtype.UUID        `json:"file_id"`
	CacheKey        string             `json:"cache_key"`
	TransformParams string             `json:"transform_params"`
	StorageKey      string             `json:"storage_key"`
	ContentType     string             `json:"content_type"`
	SizeBytes       int64              `json:"size_bytes"`
	Width           *int32             `json:"width"`
	Height          *int32             `json:"height"`
	RequestCount    int32              `json:"request_count"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	LastAccessedAt  pgtype.Timestamptz `json:"last_accessed_at"`
}

type User struct {
	ID                     pgtype.UUID        `json:"id"`
	Email                  string             `json:"email"`
	PasswordHash           *string            `json:"password_hash"`
	Name                   string             `json:"name"`
	AvatarUrl              *string            `json:"avatar_url"`
	Role                   UserRole           `json:"role"`
	SubscriptionTier       SubscriptionTier   `json:"subscription_tier"`
	StripeCustomerID       *string            `json:"stripe_customer_id"`
	StripeSubscriptionID   *string            `json:"stripe_subscription_id"`
	SubscriptionStatus     SubscriptionStatus `json:"subscription_status"`
	SubscriptionPeriodEnd  pgtype.Timestamptz `json:"subscription_period_end"`
	TrialEndsAt            pgtype.Timestamptz `json:"trial_ends_at"`
	FilesLimit             int32              `json:"files_limit"`
	MaxFileSize            int64              `json:"max_file_size"`
	StorageLimitBytes      int64              `json:"storage_limit_bytes"`
	StorageUsedBytes       int64              `json:"storage_used_bytes"`
	TransformationsCount   int32              `json:"transformations_count"`
	TransformationsLimit   int32              `json:"transformations_limit"`
	TransformationsResetAt pgtype.Timestamptz `json:"transformations_reset_at"`
	EmailVerifiedAt        pgtype.Timestamptz `json:"email_verified_at"`
	OnboardingCompletedAt  pgtype.Timestamptz `json:"onboarding_completed_at"`
	OnboardingSteps        []byte             `json:"onboarding_steps"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	DeletedAt              pgtype.Timestamptz `json:"deleted_at"`
}

type UserSetting struct {
	ID                   pgtype.UUID        `json:"id"`
	UserID               pgtype.UUID        `json:"user_id"`
	EmailNotifications   bool               `json:"email_notifications"`
	ProcessingAlerts     bool               `json:"processing_alerts"`
	MarketingEmails      bool               `json:"marketing_emails"`
	DefaultRetentionDays int32              `json:"default_retention_days"`
	AutoDeleteOriginals  bool               `json:"auto_delete_originals"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

type Webhook struct {
	ID                  pgtype.UUID        `json:"id"`
	UserID              pgtype.UUID        `json:"user_id"`
	Url                 string             `json:"url"`
	Secret              string             `json:"secret"`
	Events              []string           `json:"events"`
	Active              bool               `json:"active"`
	ConsecutiveFailures *int32             `json:"consecutive_failures"`
	LastFailureAt       pgtype.Timestamptz `json:"last_failure_at"`
	CircuitState        *string            `json:"circuit_state"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
}

type WebhookDelivery struct {
	ID            pgtype.UUID           `json:"id"`
	WebhookID     pgtype.UUID           `json:"webhook_id"`
	EventType     string                `json:"event_type"`
	Payload       []byte                `json:"payload"`
	Status        WebhookDeliveryStatus `json:"status"`
	Attempts      int32                 `json:"attempts"`
	LastAttemptAt pgtype.Timestamptz    `json:"last_attempt_at"`
	NextRetryAt   pgtype.Timestamptz    `json:"next_retry_at"`
	ResponseCode  *int32                `json:"response_code"`
	ResponseBody  *string               `json:"response_body"`
	CreatedAt     pgtype.Timestamptz    `json:"created_at"`
}
